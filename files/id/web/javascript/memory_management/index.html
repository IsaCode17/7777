---
title: Pengelolaan Memory
slug: Web/JavaScript/Memory_Management
translation_of: Web/JavaScript/Memory_Management
---
<div>{{JsSidebar("Advanced")}}</div>

<h2 id="Introduction">Pengantar</h2>

<p>Bahasa-bahasa Level Bawah, seperti C, memiliki manajemen memory level rendah yang primitiv seperti <code>malloc()</code> dan  <code>free()</code>. Pada bagian lain, nilai Javascript dialokasikan ketika sesuatu (objek, string,dll.) dibuat dan secara otomatis dibuang ketika tidak digunakan lagi. Proses terakhir disebut <em>garbage collection</em>. "Secara Otomatis" ini adalah sumber kekeliruan dan memberikan kesan developer Javascript (dan Bahasa tingkat tinggi lainnya) bahwa mereka bisa memilih untuk tidak mempedulikan tentang manajemen memory, maka itu adalah suatu kesalahan</p>

<h2 id="Siklus_hidup_sebuah_memori">Siklus hidup sebuah memori</h2>

<p>Tanpa memperhatikan bahasa pemograman, siklus hidup memori pada akhirnya selalu sama :</p>

<ol>
 <li>Mengalokasi memori yang kamu gunakan.</li>
 <li>Menggunakan alokasi memori untuk (baca, tulis).</li>
 <li>Membebaskan alokasi memori saat tidak digunakan lagi.</li>
</ol>

<p>Bagian pertama dan kedua bersifat ekplisit untuk semua bahasa. Sedangkan untuk bagian terakhir adalah eksplisit untuk bahasa tingkat rendah, tetapi hampir semua bahasa tingkat atas seperti JavaScript juga bersifat implisit.</p>

<h3 id="Allocation_in_JavaScript">Alokasi dalam JavaScript</h3>

<h4 id="Value_initialization">Inisialisasi nilai</h4>

<p>Agar tidak mengganggu pemrogram dengan alokasi, JavaScript melakukannya bersama dengan mendeklarasikan nilai.</p>

<pre class="brush: js">var n = 123; // mengalokasikan memori untuk sebuah nomor
var s = "azerty"; // mengalokasikan memori untuk string

var o = {
  a: 1,
  b: null
}; // mengalokasikan memori untuk suatu objek dan nilai yang terkandung

// (seperti objek) mengalokasikan memori untuk array dan
// berisi nilai
var a = [1, null, "abra"];

function f(a){
  return a + 2;
} // mengalokasikan fungsi (yang merupakan objek yang dapat dipanggil)

// ekspresi fungsi juga mengalokasikan objek
someElement.addEventListener('click', function(){
  someElement.style.backgroundColor = 'blue';
}, false);
</pre>

<h4 id="Allocation_via_function_calls">Alokasi melalui panggilan fungsi</h4>

<p>Beberapa panggilan fungsi menghasilkan alokasi objek.</p>

<pre class="brush: js">var d = new Date(); // mengalokasikan objek Date

var e = document.createElement('div'); // mengalokasikan elemen DOM</pre>

<p>Beberapa metode mengalokasikan nilai atau objek baru:</p>

<pre class="brush: js">var s = "azerty";
var s2 = s.substr(0, 3); // s2 adalah string baru
// Karena string adalah nilai yang tidak bisa diubah,
// JavaScript mungkin memutuskan untuk tidak mengalokasikan memori,
// tapi simpan saja kisaran [0, 3].

var a = ["ouais ouais", "nan nan"];
var a2 = ["generation", "nan nan"];
var a3 = a.concat(a2);
// larik baru dengan 4 elemen
// penggabungan elemen a dan a2
</pre>

<h3 id="Using_values">Menggunakan nilai</h3>

<p>Menggunakan nilai pada dasarnya berarti membaca dan menulis dalam memori yang dialokasikan. Ini dapat dilakukan dengan membaca atau menulis nilai variabel atau properti objek atau bahkan meneruskan argumen ke suatu fungsi.</p>

<h3 id="Release_when_the_memory_is_not_needed_anymore"> Lepaskan saat memori tidak diperlukan lagi</h3>

<p>Sebagian besar masalah manajemen memori terjadi pada fase ini. Tugas tersulit di sini adalah menemukan kapan "memori yang dialokasikan tidak diperlukan lagi". Ini sering kali mengharuskan pengembang untuk menentukan di bagian mana dalam program, bagian memori itu tidak diperlukan lagi dan membuangnya.</p>

<p>Bahasa tingkat tinggi menyematkan perangkat lunak yang disebut "pengumpul sampah" yang tugasnya melacak alokasi dan penggunaan memori untuk mengetahui kapan bagian dari memori yang dialokasikan tidak lagi diperlukan, yang secara otomatis akan membuangnya. Proses ini merupakan perkiraan karena masalah umum untuk mengetahui apakah sebagian memori diperlukan <a class="external" href="http://en.wikipedia.org/wiki/Decidability_%28logic%29">tidak dapat diputuskan</a> (tidak dapat diselesaikan dengan algoritma).</p>

<h2 id="Garbage_collection">Pengumpulan sampah</h2>

<p>Seperti yang dinyatakan di atas, masalah umum dalam menemukan secara otomatis apakah beberapa memori "tidak diperlukan lagi" tidak dapat diputuskan. Akibatnya, pengumpulan sampah menerapkan pembatasan solusi untuk masalah umum. Bagian ini akan menjelaskan pengertian yang diperlukan untuk memahami algoritma pengumpulan sampah utama dan batasannya.</p>

<h3 id="References">Referensi</h3>

<p>Gagasan utama yang diandalkan oleh algoritme pengumpulan sampah adalah gagasan <em>referensi</em>. Dalam konteks manajemen memori, suatu objek dikatakan mereferensikan objek lain jika yang pertama memiliki akses ke yang terakhir (baik secara implisit maupun eksplisit). Misalnya, objek JavaScript memiliki referensi ke <a href="/en-US/docs/Web/JavaScript/Guide/Inheritance_and_the_prototype_chain">prototype</a> (referensi implisit) dan nilai propertinya (referensi eksplisit).</p>

<p>Dalam konteks ini, pengertian "objek" diperluas ke sesuatu yang lebih luas dari objek JavaScript biasa dan juga berisi cakupan fungsi (atau cakupan leksikal global).</p>

<h3 id="Reference-counting_garbage_collection">Pengumpulan sampah penghitung-referensi</h3>

<p>Ini adalah algoritma pengumpulan sampah yang alami. Algoritma ini mengurangi definisi "sebuah objek tidak diperlukan lagi" menjadi "sebuah objek tidak memiliki objek lain yang merujuk padanya". Sebuah objek dianggap sampah yang dapat dikumpulkan jika tidak ada referensi yang menunjuk ke objek ini.</p>

<h4 id="Example">Contoh</h4>

<pre class="brush: js">var o = {
  a: {
    b:2
  }
};
// 2 objek dibuat. Yang satu direferensikan oleh yang lain sebagai
// salah satu propertinya. Yang lain direferensikan karena ditugaskan
// ke variabel 'o'. Jelas, tidak ada yang bisa dikumpulkan dari sampah

var o2 = o; // 'o2' adalah variabel kedua yang
            // memiliki referensi ke objek
o = 1;      // Sekarang, objek yang semula di 'o' memiliki referensi
            // unik diwujudkan oleh variabel 'o2'

var oa = o2.a; // referensi ke properti 'a' dari objek.
               // Objek ini sekarang memiliki 2 referensi: satu
               // sebagai properti, yang lainnya sebagai variabel 'oa'

o2 = "yo"; // Objek yang awalnya di 'o' sekarang menjadi nol
           // referensi untuk itu. Itu bisa dikumpulkan sampah.
           // Namun apa itu properti 'a' masih direferensikan oleh
           // variabel 'oa', jadi tidak bisa dibebaskan

oa = null; // Apa properti 'a' dari objek yang aslinya di o
           // tidak memiliki referensi untuk itu. Bisa jadi sampah
           // dikumpulkan.
</pre>

<h4 id="Limitation_cycles">Batasan: Siklus</h4>

<p>Ada batasan dalam hal siklus. Dalam contoh berikut, dua objek dibuat dan mereferensikan satu sama lain - sehingga menciptakan sebuah siklus. Mereka tidak akan keluar dari ruang lingkup fungsi setelah pemanggilan fungsi, sehingga mereka secara efektif tidak berguna dan dapat dibebaskan. Namun, algoritme penghitungan referensi menganggap bahwa karena masing-masing dari kedua objek direferensikan setidaknya sekali dan tidak ada yang dapat dikumpulkan dari sampah.</p>

<pre class="brush: js">function f(){
  var o = {};
  var o2 = {};
  o.a = o2; // o referensi o2
  o2.a = o; // o2 referensi o

  return "azerty";
}

f();
</pre>

<h4 id="Real-life_example">Contoh nyata</h4>

<p>Internet Explorer 6 dan 7 dikenal memiliki pengumpul sampah penghitung referensi untuk objek DOM. Siklus adalah kesalahan umum yang dapat menyebabkan kebocoran memori:</p>

<pre class="brush: js">var div;
window.onload = function(){
  div = document.getElementById("myDivElement");
  div.circularReference = div;
  div.lotsOfData = new Array(10000).join("*");
};
</pre>

<p>Pada contoh di atas, elemen DOM "myDivElement" memiliki referensi melingkar ke dirinya sendiri dalam properti "circularReference". Jika properti tidak secara eksplisit dihapus atau dinihilkan, sampah pengumpul sampah reference-counting akan selalu memiliki setidaknya satu referensi utuh dan akan menyimpan elemen DOM dalam memori meskipun dihapus dari pohon DOM. Jika elemen DOM menyimpan banyak data (diilustrasikan dalam contoh di atas dengan properti "lotsOfData"), memori yang dikonsumsi oleh data ini tidak akan pernah dilepaskan.</p>

<h3 id="Mark-and-sweep_algorithm">Algoritma Mark-and-sweep (Tendai dan Sapu)</h3>

<p>Algoritma ini mengurangi definisi "objek tidak dibutuhkan lagi" menjadi "objek tidak terjangkau".</p>

<p>Algoritma ini mengasumsikan pengetahuan sekumpulan objek yang disebut <em>roots</em> (Dalam JavaScript, root adalah objek global). Secara berkala, pengumpul sampah akan mulai dari akar ini, mencari semua objek yang dirujuk dari akar ini, kemudian semua objek yang dirujuk dari akar ini, dll. Mulai dari akar, pengumpul sampah akan menemukan semua <em> dapat dijangkau </ em > objek dan kumpulkan semua objek yang tidak dapat dijangkau.</p>

<p>Algoritma ini lebih baik daripada yang sebelumnya karena "suatu objek memiliki referensi nol" menyebabkan objek ini tidak dapat dijangkau. Kebalikannya tidak benar seperti yang kita lihat dengan siklus.</p>

<p>Mulai tahun 2012, semua peramban modern mengirimkan pengumpul sampah mark-and-sweep. Semua peningkatan yang dibuat di bidang pengumpulan sampah JavaScript (pengumpulan sampah generasi / inkremental / serentak / paralel) selama beberapa tahun terakhir merupakan peningkatan implementasi algoritme ini, tetapi bukan peningkatan atas algoritme pengumpulan sampah itu sendiri atau pengurangan definisi kapan "sebuah objek tidak dibutuhkan lagi".</p>

<h4 id="Cycles_are_not_a_problem_anymore">Siklus bukan masalah lagi</h4>

<p>Pada contoh pertama di atas, setelah pemanggilan fungsi kembali, 2 objek tidak direferensikan lagi oleh sesuatu yang dapat dijangkau dari objek global. Akibatnya, mereka akan ditemukan tidak terjangkau oleh pengumpul sampah.</p>

<p>Hal yang sama berlaku untuk contoh kedua. Setelah div dan penangannya tidak dapat dijangkau dari root, keduanya dapat dikumpulkan dari sampah meskipun saling mereferensikan.</p>

<h4 id="Limitation_objects_need_to_be_made_explicitly_unreachable">Batasan: objek harus dibuat tidak terjangkau secara eksplisit</h4>

<p>Meskipun ini ditandai sebagai batasan, ini adalah salah satu yang jarang tercapai dalam praktiknya, itulah sebabnya biasanya tidak ada orang yang terlalu peduli dengan pengumpulan sampah.</p>

<h2 id="See_also">Lihat juga</h2>

<ul>
 <li><a class="external" href="http://www.ibm.com/developerworks/web/library/wa-memleak/">IBM article on "Memory leak patterns in JavaScript" (2007)</a></li>
 <li><a class="external" href="http://msdn.microsoft.com/en-us/magazine/ff728624.aspx">Kangax article on how to register event handler and avoid memory leaks (2010)</a></li>
 <li><a href="https://developer.mozilla.org/en-US/docs/Mozilla/Performance" title="https://developer.mozilla.org/en-US/docs/Mozilla/Performance">Performance</a></li>
</ul>
