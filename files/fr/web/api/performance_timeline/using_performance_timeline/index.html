---
title: Utilisation de Performance Timeline
slug: Web/API/Performance_Timeline/Using_Performance_Timeline
tags:
  - Guide
  - Performance
  - Performance Web
translation_of: Web/API/Performance_Timeline/Using_Performance_Timeline
---
<div>{{DefaultAPISidebar("Performance Timeline API")}}</div>

<p>La norme <strong><a href="https://w3c.github.io/performance-timeline/">Performance Timeline</a></strong> définit des extensions de l'interface {{domxref("Performance")}} pour prendre en charge les mesures de latence côté client au sein des applications. La norme comprend également des interfaces qui permettent à une application d'être notifiée lorsque des événements de performance spécifiques se produisent. Ensemble, ces interfaces peuvent être utilisées pour aider à identifier les goulots d'étranglement des performances d'une application.</p>

<h2 id="Performance_extensions">Extensions de <code>Performance</code></h2>

<p><strong>Performance Timeline</strong> étend l'objet {{domxref("Performance")}} avec trois méthodes qui fournissent différents mécanismes pour obtenir un ensemble d'{{domxref("PerformanceEntry", "enregistrements des performances (métriques)", "", 1)}}, selon les critères de filtrage spécifiés. L'exemple suivant montre l'utilisation de ces méthodes {{domxref("Performance.getEntries", "getEntries()")}}, {{domxref("Performance.getEntriesByName", "getEntriesByName()")}} et {{domxref("Performance.getEntriesByType", "getEntriesByType()")}}.</p>

<pre class="brush: js">
  function log(s) {
    var o = document.getElementsByTagName("output")[0];
    o.innerHTML += s + " &lt;br&gt;";
  }
  function do_work (n) {
    for (var i=0 ; i &lt; n; i++) {
       var m = Math.random();
    }
  }
  function print_perf_entry(pe) {
    log("..name: "        + pe.name      +
        "; entryType: " + pe.entryType +
        "; startTime: " + pe.startTime +
        "; duration: "  + pe.duration);
  }
  function print_PerformanceEntries() {
    if (performance.mark === undefined) {
      log("... performance.mark Not supported");
      return;
    }

    // Crée quelques entrées de performance via les méthodes mark() et measure()
    performance.mark("Begin");
    do_work(50000);
    performance.mark("End");
    do_work(50000);
    performance.measure("Measure1", "Begin", "End");

    // Utilise getEntries() pour itérer toutes les entrées.
    var p = performance.getEntries();
    for (var i=0; i &lt; p.length; i++) {
      log("All Entry[" + i + "]");
      print_perf_entry(p[i]);
    }

    // Utilise getEntries(name, entryType) pour obtenir des entrées spécifiques.
    p = performance.getEntries({name : "Measure1", entryType:   "measure"});
    for (var i=0; i &lt; p.length; i++) {
      log("Begin and Measure [" + i + "]");
      print_perf_entry(p[i]);
    }

    // Utilisez getEntriesByType() pour obtenir toutes les entrées "mark".
    p = performance.getEntriesByType("mark");
    for (var i=0; i &lt; p.length; i++) {
      log ("Mark only [" + i + "]");
      print_perf_entry(p[i]);
    }

    // Utilise getEntriesByName() pour obtenir toutes les entrées "mark" nommées "Begin".
    p = performance.getEntriesByName("Begin", "mark");
    for (var i=0; i &lt; p.length; i++) {
      log ("Begin and Mark [" + i + "]");
      print_perf_entry(p[i]);
    }
  }
</pre>

<h2 id="PerformanceEntry_interface">L'interface <code>PerformanceEntry</code></h2>

<p>L'interface {{domxref("PerformanceEntry")}} encapsule une seule <em>entrée de performance</em>, c'est-à-dire une seule métrique de performance. Cette interface possède quatre propriétés et un <em>sérialiseur</em> JSON : ({{domxref("Performance.toJSON", "toJSON()")}}. L'exemple suivant montre l'utilisation de ces propriétés.</p>

<pre class="brush: js">
  function print_PerformanceEntry(ev) {
    var properties = ["name", "entryType", "startTime", "duration"];

    // Crée quelques entrées de performance
    performance.mark("Start");
    do_work(50000);
    performance.mark("Stop");
    performance.measure("measure-1");

    var p = performance.getEntries();
    for (var i=0; i &lt; p.length; i++) {
      log("PerfEntry[" + i + "]");
      for (var j=0; j &lt; properties.length; j++) {
        // check each property in window.performance
        var supported = properties[j] in p[i];
        if (supported) {
          var pe = p[i];
          log("... " + properties[j] + " = " + pe[properties[j]]);
        } else {
          log("... " + properties[j] + " = Not supported");
        }
      }
    }
  }
</pre>

<p>Cette interface comprend également une méthode {{domxref("PerformanceEntry.toJSON", "toJSON()")}} qui renvoie la sérialisation de l'objet {{domxref("PerformanceEntry")}}. Les exemples suivants montrent l'utilisation de cette méthode.</p>

<pre class="brush: js">
  function PerfEntry_toJSON() {

    // Crée quelques entrées de performance
    performance.mark("mark-1");
    performance.mark("mark-2");
    performance.measure("meas-1", "mark-1", "mark-2");

    var peList = performance.getEntries();
    var pe = peList[0];

    if (pe.toJSON === undefined) {
      log ("PerformanceEntry.toJSON() n'est PAS pris en charge");
      return;
    }

    // Imprime l'objet PerformanceEntry
    var json = pe.toJSON();
    var s = JSON.stringify(json);
    log("PerformanceEntry.toJSON = " + s);
  }
</pre>

<h2 id="Performance_Observers">Observateurs de performance</h2>

<p>{{SeeCompatTable}}</p>

<p>Les interfaces <em>Performance Observer</em> permettent à une application d'enregistrer un <em>observateur</em> pour des types d'événements de performance spécifiques, et lorsqu'un de ces types d'événements est enregistré, l'application est <em>notifiée</em> de l'événement via la fonction de rappel de l'observateur qui a été spécifiée au moment, où l'observateur a été créé. Lorsque l'observateur (rappel ou « callback ») est invoqué, les paramètres du rappel incluent une <em>{{domxref("PerformanceObserverEntryList", "liste d'entrées de l'observateur de performance", "", 1)}}</em> qui contient uniquement des {{domxref("PerformanceEntry", "entrées de performance", "", 1)}} <em>observées</em>. C'est-à-dire que la liste ne contient que des entrées pour les types d'événements qui ont été spécifiés lorsque la méthode {{domxref("PerformanceObserver.observe", "observe()")}} de l'observateur a été invoquée.</p>

<p>L'exemple suivant montre comment enregistrer deux observateurs : le premier s'enregistre pour plusieurs types d'événements et le second ne s'enregistre que pour un seul type d'événement.</p>

<pre class="brush: js">
  function PerformanceObservers() {
    // Crée un observateur pour tous les types d'événements de performance
    var observe_all = new PerformanceObserver(function(list, obs) {
      var perfEntries;

      // Imprime toutes les entrées
      perfEntries = list.getEntries();
      for (var i=0; i &lt; perfEntries.length; i++) {
        print_perf_entry(perfEntries[i]);
      }

      // Imprime les entrées nommées "Begin" avec le type "mark".
      perfEntries = list.getEntriesByName("Begin", "mark");
      for (var i=0; i &lt; perfEntries.length; i++) {
        print_perf_entry(perfEntries[i]);
      }

      // Imprime les entrées avec le type "marque".
      perfEntries = list.getEntriesByType("mark");
      for (var i=0; i &lt; perfEntries.length; i++) {
        print_perf_entry(perfEntries[i]);
      }
    });
    // inscrit tous les types d'événements liés aux performances
    observe_all.observe({entryTypes: ['frame', 'mark', 'measure', 'navigation', 'resource', 'server']});

    // Crée un observateur pour le seul type d'événement "mark".
    var observe_mark = new PerformanceObserver(function(list, obs) {
      var perfEntries = list.getEntries();
      // Ne devrait avoir que des entrées de type "mark".
      for (var i=0; i &lt; perfEntries.length; i++) {
        print_perf_entry(perfEntries[i]);
      }
    });
    // inscrit uniquement l'événement "mark".
    observe_mark.observe({entryTypes: ['mark']});
  }
  function print_perf_entry(pe) {
    log("name: "        + pe.name      +
        "; entryType: " + pe.entryType +
        "; startTime: " + pe.startTime +
        "; duration: "  + pe.duration);
  }
</pre>

<p>L'interface {{domxref("PerformanceObserverEntryList", "liste des entrées de l'observateur de performance", "", 1)}} possède les trois mêmes méthodes <code>getEntries*()</code> que l'interface {{domxref("Performance")}} et ces méthodes sont utilisées pour récupérer les entrées de performance <em>observées</em> dans le rappel de l'observateur. Ces méthodes ont été utilisées dans l'exemple cité ci-dessus.</p>

<h2 id="Specifications">Spécifications</h2>

<p>Les interfaces décrites dans ce document sont définies dans la norme <strong>Performance Timeline</strong> qui comporte deux niveaux :</p>

<table class="standard-table">
  <thead>
    <tr>
      <th scope="col">Spécification</th>
      <th scope="col">Statut</th>
      <th scope="col">Commentaire</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>{{SpecName('Performance Timeline',  '#extensions-to-the-performance-interface', 'Performance   extensions')}}</td>
      <td>{{Spec2('Performance Timeline')}}</td>
      <td>Définition des méthodes <code>getEntries()</code>, <code>getEntriesByType()</code> et <code>getEntriesByName()</code>.</td>
    </tr>
    <tr>
      <td>{{SpecName('Performance Timeline Level 2',  '#extensions-to-the-performance-interface', 'Performance   extensions')}}</td>
      <td>{{Spec2('Performance Timeline Level 2')}}</td>
      <td>Modifications de l'interface <code>getEntries()</code>.</td>
    </tr>
  </tbody>
 </table>

<h2 id="See_also">Voir aussi</h2>

<ul>
  <li><a href="/fr/docs/Web/API/Performance_Timeline">Performance Timeline API</a></li>
  <li><a href="https://siusin.github.io/perf-timing-primer/">Une introduction aux API de chronométrage des performances du Web</a></li>
</ul>
