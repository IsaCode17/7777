---
title: 비동기 JavaScript 입문
slug: Learn/JavaScript/Asynchronous/Introducing
translation_of: Learn/JavaScript/Asynchronous/Introducing
tags:
  - Beginner
  - CodingScripting
  - Guide
  - Introducing
  - JavaScript
  - Learn
  - Promises
  - async
  - asynchronous
  - await
  - callbacks
  - 가이드
  - 입문
  - 자바스크립트
  - 학습
  - 프로미스
  - 어싱크
  - 비동기
  - 어웨이트
  - 콜백
---
<div>{{LearnSidebar}}</div>

<div>{{PreviousMenuNext("Learn/JavaScript/Asynchronous/Concepts", "Learn/JavaScript/Asynchronous/Timeouts_and_intervals", "Learn/JavaScript/Asynchronous")}}</div>

<p class="summary">이 문서에선 JavaScript의 동기식 처리와 관련된 문제를 간략하게 돌아보고, 앞으로 접하게 될 다른 비동기 기술들을 살펴보며, 어떻게 우리에게 도움이 될 수 있는지 살펴봅니다.</p>

<table class="learn-box standard-table">
 <tbody>
  <tr>
   <th scope="row">필요한 사전 지식:</th>
   <td>기본적인 컴퓨터 활용 능력, JavaScript 기초에 대한 이해.</td>
  </tr>
  <tr>
   <th scope="row">학습 목표:</th>
   <td>
    <p>비동기식 JavaScript와 좀 더 친숙해지고, 동기식 JavaScript와 어떻게 다르며 어떤 사용처가 있는지 안다.</p>
   </td>
  </tr>
 </tbody>
</table>

<h2 id="Synchronous_JavaScript">동기식 JavaScript</h2>

<p><strong>{{Glossary("asynchronous")}}</strong> JavaScript가 무엇인지 이해하려면, 먼저 <strong>{{Glossary("synchronous")}}</strong> JavaScript가 무엇인지 알아야 합니다. 이 부분에선 이전 문서에서 배웠던 내용을 복습해봅시다.</p>

<p>이전의 학습 모듈에서 살펴본 대다수의 기능들은 동기식입니다. 코드를 실행하면, 브라우저가 할 수 있는 한 빠르게 결과를 보여줍니다. 간단한 예제를 살펴봅시다 (<a href="https://mdn.github.io/learning-area/javascript/asynchronous/introducing/basic-function.html">동작하는 예제는 여기에서</a>, <a href="https://github.com/mdn/learning-area/blob/master/javascript/asynchronous/introducing/basic-function.html">소스는 여기에서 볼 수 있습니다</a>).</p>

<pre class="brush: js">const btn = document.querySelector('button');
btn.addEventListener('click', () =&gt; {
  alert('You clicked me!');

  let pElem = document.createElement('p');
  pElem.textContent = 'This is a newly-added paragraph.';
  document.body.appendChild(pElem);
});
</pre>

<p>이 블록에서 코드는 위에서 아래로 차례대로 실행됩니다.</p>

<ol>
 <li>DOM에 미리 정의된 {{htmlelement("button")}} 요소의 참조를 가져옵니다.</li>
 <li><code><a href="/ko/docs/Web/API/Element/click_event">click</a></code> 이벤트 수신기를 버튼에 추가해 버튼을 클릭하면 아래 기능을 차례로 실행합니다.
  <ol>
   <li><code><a href="/ko/docs/Web/API/Window/alert">alert()</a></code> 메시지가 나타납니다.</li>
   <li>alert가 사라지면 {{htmlelement("p")}} 요소를 만듭니다.</li>
   <li>만든 문단 요소에 내용 문자열을 넣습니다.</li>
   <li>마지막으로 문서 body에 문단을 추가합니다.</li>
  </ol>
 </li>
</ol>

<p>각 작업이 처리되는 동안 다른 일은 일어나지 못합니다. 렌더링 과정은 잠시 중단됩니다. <a href="/ko/docs/Learn/JavaScript/Asynchronous/Concepts">이전 문서</a>에서 얘기했듯이, <a href="/ko/docs/Learn/JavaScript/Asynchronous/Concepts#javascript_is_single_threaded">JavaScript는 싱글 스레드</a>이기 때문입니다. 한 번에 한 작업만, 하나의 메인 스레드에서 처리될 수 있습니다. 다른 작업은 앞선 작업이 끝나야 수행됩니다.</p>

<p>따라서 앞의 예제는 사용자가 alert의 확인 버튼을 누를 때까지 문장이 나타나지 않습니다. 아래에서 직접 확인해보세요.</p>

<div class="hidden">
<pre class="brush: html">&lt;<span class="pl-ent">button</span>&gt;Click me&lt;/<span class="pl-ent">button</span>&gt;</pre>
</div>

<p>{{EmbedLiveSample('Synchronous_JavaScript', '100%', '110px')}}</p>

<div class="notecard note">
<p><strong>Note</strong>: <code><a href="/ko/docs/Web/API/Window/alert">alert()</a></code>는 동기식의 블로킹 작업을 설명하는데 아주 유용하지만, 실제 어플리케이션에서는 사용하기에는 끔찍한 선택지라는걸 기억해주세요.</p>
</div>

<h2 id="Asynchronous_JavaScript">비동기식 JavaScript</h2>

<p>앞서 설명된 이유들 (블로킹과 관련된) 때문에 지금의 많은 웹 API 기능은 비동기 코드로 실행되고 있습니다. 특히 외부 기기에서 어떤 종류의 리소스에 접근하거나 가져오는 기능들에 많이 사용합니다. 예를 들어 네트워크에서 파일을 가져오거나, 데이터베이스에 접근해 특정 데이터를 가져오는 일, 웹캠에서 비디오 스트림에 접근하거나, 화면을 VR 헤드셋으로 보내는 일 등이 있습니다.</p>

<p>이런 작업들을 동기식 코드를 사용하여 처리하는 것은 왜 어려운 일일까요? 다음 예제를 살펴보겠습니다. 서버에서 이미지를 가져온다고 할 때, 이미지는 코드를 호출해도 바로 사용할 수 없습니다. 이는 아래(의사 코드)처럼 작성하면 제대로 동작하지 않는다는 의미입니다.</p>

<pre class="brush: js">let response = fetch('myImage.png');
let blob = response.blob();
// 이미지 blob을 UI 어디에선가 표시하는 코드</pre>

<p>왜냐하면 이미지를 다운로드 받는 데 얼마나 걸릴지 모르기 때문입니다. 그래서 두 번째 줄을 실행하면 에러가 발생합니다(이미지의 크기가 아주 작다면 에러가 발생하지 않을 수도 있습니다. 반대로 이미지의 크기가 크면 매번 발생할 것 입니다). 왜냐하면 <code>response</code> 가 아직 반환되지 않았기 때문입니다. 따라서 개발자는 <code>response</code> 가 반환되기 전까지 기다리도록 처리해야 합니다.</p>

<p>JavaScript 코드에서 볼 수 있는 비동기 처리 방식은 크게 두 가지 유형이 있습니다. 예전 방식인 콜백과 새로운 방식인 프로미스입니다. 이제부터 차례대로 살펴보겠습니다.</p>

<h2 id="Async_callbacks">비동기 콜백</h2>

<p>비동기 콜백은 백그라운드에서 코드 실행을 시작할 함수를 호출할 때 매개변수로 지정된 함수입니다. 백그라운드 코드 실행이 끝나면 콜백 함수를 호출하여 작업이 완료됐음을 알리거나, 프로그래머의 관심이 필요한 다른 일이 일어났다고 알려줄 수 있습니다. 요즘 콜백을 사용하는 건 약간 옛날 방식이지만, 예전에 만들어졌으나 아직 범용적으로 쓰이고 있는 여러 API에서 볼 수 있습니다.</p>

<p>비동기 콜백의 예시 중 하나는 {{domxref("EventTarget.addEventListener", "addEventListener()")}}의 두 번째 매개변수 입니다.</p>

<pre class="brush: js">btn.addEventListener('click', () =&gt; {
  alert('You clicked me!');

  let pElem = document.createElement('p');
  pElem.textContent = 'This is a newly-added paragraph.';
  document.body.appendChild(pElem);
});</pre>

<p>첫 번째 매개변수는 이벤트 리스너 유형이며, 두 번째 매개변수는 이벤트가 발생할 때 호출되는 콜백 함수입니다.</p>

<p>콜백 함수를 다른 함수의 매개변수로 전달할 때, 함수의 참조를 매개변수로 전달할 뿐입니다. 콜백 함수는 바로 실행되지는 <strong>않고</strong>, 다른 함수의 본문에서 비동기적으로 “called back” (이름대로 나중에 호출)됩니다. 콜백 함수를 담고 있는 함수는 때가 되면 콜백 함수를 실행할 책임이 있습니다.</p>

<p>콜백을 사용한 함수는 여러분도 쉽게 만드실 수 있습니다. <a href="/en-US/docs/Web/API/XMLHttpRequest"><code>XMLHttpRequest</code> API</a> (<a href="https://mdn.github.io/learning-area/javascript/asynchronous/introducing/xhr-async-callback.html">동작하는 예제는 여기에서</a>, <a href="https://github.com/mdn/learning-area/blob/master/javascript/asynchronous/introducing/xhr-async-callback.html">소스는 여기에서 확인하세요</a>)로 리소스를 불러오는 예제를 확인해봅시다.</p>

<pre class="brush: js">function loadAsset(url, type, callback) {
  let xhr = new XMLHttpRequest();
  xhr.open('GET', url);
  xhr.responseType = type;

  xhr.onload = function() {
    callback(xhr.response);
  };

  xhr.send();
}

function displayImage(blob) {
  let objectURL = URL.createObjectURL(blob);

  let image = document.createElement('img');
  image.src = objectURL;
  document.body.appendChild(image);
}

loadAsset('coffee.jpg', 'blob', displayImage);</pre>

<p>blob을 받아 객체 URL로 만들고, 이미지에 넣어 <code>&lt;body&gt;</code>에 추가해 화면에 그리는 <code>displayImage()</code>함수를 만들었습니다. 그런 다음 콜백 함수와 불러올 url, 콘텐츠 타입을 매개변수로 받는 <code>loadAsset()</code> 함수를 만들어봅시다. <code>XMLHttpRequest</code> (줄여서 "XHR") 를 사용하여 URL에서 리소스를 가져온 다음 응답을 콜백으로 전달하여 다른 작업을 수행합니다. 이 경우 콜백은 XHR 호출이 리소스 다운로드를 완료할 때 까지 대기합니다. (<code><a href="/en-US/docs/Web/API/XMLHttpRequestEventTarget/onload">onload</a></code> 이벤트 처리기 사용)</p>

<p>콜백은 다재다능 합니다. 콜백은 함수가 실행되는 순서와 함수간에 전달되는 데이터를 제어할 수 있을 뿐 아니라, 데이터를 상황에 따라 다른 함수로 전달할 수 있게 해줍니다. 응답받은 데이터가 json이라면 <code>processJSON()</code>, 단순 문자열이라면 <code>displayText()</code> 를 호출하는 등 유연하게 작업을 처리할 수 있습니다.</p>

<p>모든 콜백이 비동기인건 아니라는 점에 유의하세요. 동기적으로 실행되는 콜백도 있습니다. 예를 들어 {{jsxref("Array.prototype.forEach()")}} 를 사용하여 배열의 항목을 탐색하는 경우입니다 (<a href="https://mdn.github.io/learning-area/javascript/asynchronous/introducing/foreach.html">동작하는 예제는 여기에서</a>, <a href="https://github.com/mdn/learning-area/blob/master/javascript/asynchronous/introducing/foreach.html">소스는 여기에서 확인하세요</a>).</p>

<pre class="brush: js">const gods = ['Apollo', 'Artemis', 'Ares', 'Zeus'];

gods.forEach(function (eachName, index){
  console.log(index + '. ' + eachName);
});</pre>

<p>이 예제에선 그리스 신들의 이름을 저장한 배열을 순회하며 인덱스 숫자와 요소 값을 콘솔에 출력합니다. <code>forEach()</code>는 매개변수로 콜백 함수를 받으며, 콜백 함수는 배열의 이름 값에 대한 참조와 인덱스, 두 개의 매개변수를 받습니다. 그러나 여기선 비동기로 처리되지 않고 즉시 실행됩니다.</p>

<h2 id="Promises">프로미스</h2>

<p>프로미스는 현대 Web API에서 자주 보게 될 새로운 비동기 코드 스타일입니다. 프로미스의 좋은 예시로는 <code><a href="/en-US/docs/Web/API/WindowOrWorkerGlobalScope/fetch">fetch()</a></code> API가 있는데요, <code><a href="/en-US/docs/Web/API/WindowOrWorkerGlobalScope/fetch">fetch()</a></code>는 {{domxref("XMLHttpRequest")}}의 좀 더 현대적이고 효율적인 버전입니다. 아래 <a href="/ko/docs/Learn/JavaScript/Client-side_web_APIs/Fetching_data">Fetching data from the server</a> 예제에서 빠르게 살펴봅시다.</p>

<pre class="brush: js">fetch('products.json').then(function(response) {
  return response.json();
}).then(function(json) {
  products = json;
  initialize();
}).catch(function(err) {
  console.log('Fetch problem: ' + err.message);
});</pre>

<div class="notecard note">
<p><strong>Note</strong>: GitHub에서 완성된 예제를 보실 수 있습니다 (<a href="https://github.com/mdn/learning-area/blob/master/javascript/apis/fetching-data/can-store-xhr/can-script.js">소스는 여기에서</a>, <a href="https://mdn.github.io/learning-area/javascript/apis/fetching-data/can-store-xhr/">동작하는 예제는 여기에서 확인하세요</a>).</p>
</div>

<p><code>fetch</code><code>()</code> 는 하나의 매개변수(네트워크에서 가지고 오고 싶은 리소스의 URL)를 받아 <a href="/ko/docs/Web/JavaScript/Reference/Global_Objects/Promise">프로미스</a>를 반환합니다. 프로미스는 비동기 작업의 완료 또는 실패를 나타내는 객체입니다. 말하자면 작업의 중간 상태를 나타냅니다. 이는 "가능한 한 빨리 답변을 준다고 약속(promise)할게" 라고 브라우저가 말하는 방식이며, 그래서 "약속"이라는 이름이 붙었습니다.</p>

<p>이 개념에 익숙해지기 위해서 연습이 필요할 수 있습니다. 약간 {{interwiki("wikipedia", "Schrödinger's cat")}}(슈뢰딩거의 고양이)를 보는듯한 느낌을 받으실겁니다. 발생 가능한 결과 중 아직 아무것도 발생하지 않았기 때문에, fetch 작업은 브라우저가 작업을 끝마치는 것을 기다리고 있습니다. <code>fetch()</code> 뒤에 세 개의 코드 블럭이 체이닝되어 있는데 이를 살펴봅시다.</p>

<ul>
 <li>두 개의 <code><a href="/ko/docs/Web/JavaScript/Reference/Global_Objects/Promise/then">then()</a></code> 블록: 두 블록 모두 이전 작업이 성공했을 때 수행할 콜백 함수를 담고 있으며, 각 콜백은 매개변수로 이전의 성공한 작업 결과를 전달받으므로, 이 결과를 가지고 다른 작업을 수행할 수 있습니다. 각 <code>.then()</code> 블록은 새로운 프로미스를 반환합니다. 즉 각각의 프로미스에 따로 <code>.then()</code> 을 여러 개 체이닝하여 비동기 작업들을 순서대로(하나가 끝나면 다음 하나를) 실행할 수 있습니다.</li>
 <li>마지막의 <code><a href="/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise/catch">catch()</a></code> 블록은 <code>.then()</code> 이 하나라도 실패하면 동작합니다. 이는 동기 방식의 <code><a href="/en-US/docs/Web/JavaScript/Reference/Statements/try...catch">try...catch</a></code> 블록과 비슷합니다. <code>catch()</code>블럭 안에서는 error 객체를 사용할 수 있으며, 발생한 오류를 알아보는 용도로 사용합니다. <code>try...catch</code> 는 프로미스와 함께 동작하지 않지만, 나중에 배울 <a href="/en-US/docs/Learn/JavaScript/Asynchronous/Async_await">async/await</a>에서는 동작한다는 점에 유의하세요.</li>
</ul>

<div class="notecard note">
<p><strong>Note</strong>: 이 모듈의 뒷부분에 프로미스의 더 많은 부분을 배웁니다. 지금 이해하지 못하셨더라도 걱정하지 마세요.</p>
</div>

<h3 id="The_event_queue">이벤트 큐</h3>

<p>프로미스같은 비동기 작업들은 <strong>이벤트 큐</strong>에 들어갑니다. 이 작업들은 메인 스레드 작업이 끝난 후 실행되어 후속 JavaScript 코드가 차단되는것을 방지합니다. 큐에 들어간 작업은 최대한 빨리 처리되어 JavaScript 환경으로 결과를 반환해줍니다.</p>

<h3 id="Promises_vs_callbacks">프로미스 vs 콜백</h3>

<p>프로미스는 옛날 방식 콜백과 비슷한 점이 있습니다. 프로미스는 본질적으로 함수에 콜백을 직접 넘기는 대신 반환된 객체에 여러분이 콜백을 직접 연결하는 것에 불과합니다.</p>

<p>그러나 프로미스는 비동기 작업을 처리하기 위해 만들어졌고, 옛날 방식 콜백보다 장점이 많습니다.</p>

<ul>
 <li>여러 비동기 작업을 체이닝할 때 앞서 본 예제처럼 <code>.then()</code> 을 사용하여 결과값을 다음 작업으로 넘길 수 있습니다. 콜백으로 같은 작업을 하고자 하면 더 어려워지는데요, "파멸의 피라미드" (<a href="http://callbackhell.com/">콜백 지옥</a>로 잘 알려져 있습니다)로 귀결되는 모습을 자주 볼 수 있습니다.</li>
 <li>프로미스 콜백은 항상 엄격하게 이벤트 큐에 배치된 순서대로 호출됩니다.</li>
 <li>에러 처리가 훨씬 수월합니다. 모든 에러를 코드 블럭의 마지막 부분에 있는 단 하나의 <code>.catch()</code> 블록으로 처리할 수 있습니다. 이 방법은 "피라미드"의 각 단계에서 에러를 핸들링하는 것 보다 훨씬 간단합니다.</li>
 <li>프로미스는 제어의 반전(inversion of control)이 일어나지 않습니다. 옛날 방식 콜백은 서드 파티 라이브러리에 전달될 때 함수가 실행되는 방법에 대한 완전한 제어를 잃어버리는 반면에, 프로미스는 그렇지 않습니다.</li>
</ul>

<h2 id="The_nature_of_asynchronous_code">비동기 코드의 특성</h2>

<p>비동기 코드의 특성을 설명하는 예시를 살펴봅시다. 이 예제는 코드의 실행 순서를 완벽하게 파악하지 못하여 비동기 방식 코드를 동기 방식 코드처럼 다루려고 했을 때 나타나는 문제를 담고 있습니다. 아래 예제는 이전에 봤던 예제와 유사합니다. (<a href="https://mdn.github.io/learning-area/javascript/asynchronous/introducing/async-sync.html">동작하는 예제는 여기에서</a>, <a href="https://github.com/mdn/learning-area/blob/master/javascript/asynchronous/introducing/async-sync.html">소스는 여기에서 확인하세요</a>). 한가지 다른 점은 코드가 실행순서를 보여주기 위해 {{domxref("console.log()")}} 를 추가했습니다.</p>

<pre class="brush: js">console.log ('Starting');
let image;

fetch('coffee.jpg').then((response) =&gt; {
  console.log('It worked :)')
  return response.blob();
}).then((myBlob) =&gt; {
  let objectURL = URL.createObjectURL(myBlob);
  image = document.createElement('img');
  image.src = objectURL;
  document.body.appendChild(image);
}).catch((error) =&gt; {
  console.log('There has been a problem with your fetch operation: ' + error.message);
});

console.log ('All done!');</pre>

<p>브라우저가 코드를 실행하기 시작하면, <code>Starting</code>이 적힌 <code>console.log()</code> 문을 만나 실행하고, <code>image</code> 변수를 만들 것 입니다.</p>

<p>그 뒤에 다음 줄로 이동하여 <code>fetch()</code> 블록을 실행하려고 하지만, <code>fetch()</code> 는 블로킹 없이 비동기적으로 실행되기 때문에 프로미스와 관련된 작업들을 지나쳐 아래쪽의 코드를 이어서 실행할 겁니다. 그래서 마지막의 <code>console.log()</code>(<code>All done!</code>)를 만나 메시지를 콘솔에 출력합니다.</p>

<p><code>fetch()</code> 블록 작업이 완전히 끝나고 <code>.then()</code> 블록에 결과를 전달해야만 <code>console.log()</code> 의 메시지(<code>It worked :)</code>)가 나타납니다. 결국 메시지의 순서는 여러분의 처음 생각과는 다르게 순서가 바뀌어서 나타납니다.</p>

<ul>
 <li>Starting</li>
 <li>All done!</li>
 <li>It worked :)</li>
</ul>

<p>이 예시가 헷갈린다면 다음의 간략한 예제를 살펴보세요.</p>

<pre class="brush: js">console.log("클릭 처리기를 등록합니다");

button.addEventListener('click', () =&gt; {
  console.log("클릭함");
});

console.log("끝");</pre>

<p>이전 예제와 매우 비슷한 동작을 합니다. 첫 번째와 세 번째<code>console.log()</code> 메시지는 콘솔창에 바로 출력되지만, 두 번째 메시지는 누군가가 버튼을 클릭하기 전엔 콘솔에 표시되지 않습니다. 이전 예제와의 차이는 두 번쩨 메시지가 블로킹되는 이유인데, 첫 예제는 리소스를 가져오고 화면에 표시하는 프로미스 체이닝 작업을 기다리느라 발생하지만, 이번 예제는 클릭 이벤트를 기다리느라 발생합니다.</p>

<p>다시 처음 'coffee.jpg'를 불러오는 코드 예제를 기준으로 설명드리면, 이런 방식(비동기 방식 코드가 끝날 것이라 가정하고 동기 코드를 작성하는 방식)의 코드는 문제가 될 수 있습니다. 비동기 방식 코드 블록에서 반환된 결과를 동기 방식 코드 블록에서 사용할 수 없기 때문입니다. 브라우저는 동기 방식 코드 블록을 처리하기 전에 비동기 코드 블록 작업이 끝날 것이라 보장하지 않습니다.</p>

<p>어떤 의미인지 확인하려면 <a href="https://github.com/mdn/learning-area/blob/master/javascript/asynchronous/introducing/async-sync.html">이 예제</a>를 컴퓨터에 복사한 후 마지막 <code>console.log()</code> 를 아래처럼 고쳐보세요.</p>

<pre class="brush: js">console.log ('All done! ' + image.src + 'displayed.');</pre>

<p>고치고 나면 콘솔창에서 아래와 같은 에러가 뜨는것을 확인할 수 있습니다.</p>

<pre class="notranslate"><span class="message-body-wrapper"><span class="message-flex-body"><span class="devtools-monospace message-body">TypeError: image is undefined; can't access its "src" property</span></span></span></pre>

<p>이는 브라우저가 마지막 <code>console.log()</code> 문을 실행하려고 할 때, <code>fetch()</code> 블록의  작업이 끝나지 않아 <code>image</code> 변수에 값이 할당되지 않았기 때문입니다.</p>

<div class="notecard note">
<p><strong>Note</strong>: 보안상의 이유로, <code>fetch()</code>로 로컬 파일시스템의 파일을 불러오는 것(또는 로컬에서 다른 작업을 실행하는 것)은 불가능합니다. 위 예시를 로컬에서 실행하려면 <a href="/ko/docs/Learn/Common_questions/set_up_a_local_testing_server">로컬 웹서버</a>를 통해 실행해야 합니다.</p>
</div>

<h2 id="Active_learning_make_it_all_async!">Active learning: 모두 비동기로 만들자!</h2>

<p>위의 문제 있는 <code>fetch()</code> 예시에서 모든 <code>console.log()</code>가 순서대로 나타나도록 고칠 수 있습니다. 세 번째 <code>console.log()</code> 도 비동기로 작동시키면 됩니다. 두 번째 <code>.then()</code> 블록의 뒤에 새로운 <code>.then()</code> 블록을 만들어 집어넣거나, 두 번째 <code>.then()</code> 블록 안에 집어넣으면 콘솔에 순서대로 나타날 것 입니다. 지금 바로 고쳐보세요!</p>

<div class="notecard note">
<p><strong>Note</strong>: 막혔다면, <a href="https://github.com/mdn/learning-area/blob/master/javascript/asynchronous/introducing/async-sync-fixed.html">여기에서 정답을 확인할 수 있습니다</a> (동작하는 예시는 <a href="https://mdn.github.io/learning-area/javascript/asynchronous/introducing/async-sync-fixed.html">여기에서</a> 확인하세요). 프로미스에 대한 더 자세한 정보는 이 모듈 뒷편의 <a href="/ko/docs/Learn/JavaScript/Asynchronous/Promises">프로미스와 함께하는 우아한 비동기 프로그래밍</a> 가이드에서 확인할 수 있습니다.</p>
</div>

<h2 id="Conclusion">결론</h2>

<p>가장 기본적인 형태의 JavaScript는 한 번에 한 가지 작업만 진행할 수 있는 동기식, 블로킹, 싱글 스레드 언어입니다. 하지만 웹 브라우저는 동기적으로 실행해서는 안되는 함수를 위해, 어떤 이벤트(시간의 흐름, 사용자가 마우스로 상호작용, 네트워크에서 데이터가 도착함 등)가 일어났을 때 비동기적으로 호출할 수 있도록 함수와 API를 정의하고 있습니다. 이는 메인 스레드를 멈추거나 블로킹하지 않고도 한 번에 여러 코드를 실행할 수 있다는 것을 의미합니다.</p>

<p>코드를 동기적으로 실행할지 비동기적으로 실행할지는 하려는 작업이 무엇인지에 달려있습니다.</p>

<p>불러와 적용하는 것이 바로 일어나기를 바랄 때도 있을겁니다. 예를 들어 웹 페이지에 사용자 정의 스타일을 적용할 때는 스타일이 가능한 한 빨리 적용되기를 바랄겁니다.</p>

<p>그러나 데이터베이스를 질의한 결과를 템플릿을 만드는 데 사용한다던가 하는 등의 시간이 걸리는 작업을 할 때는 메인 스레드에서 작업하기 보다는 비동기적으로 작업하는 게 좋을 것 입니다. 시간이 지날수록 동기 방식보다 비동기 방식을 선택하는게 나은 경우를 고르는 안목이 생기게 될 것 입니다.</p>

<ul>
</ul>

<p>{{PreviousMenuNext("Learn/JavaScript/Asynchronous/Concepts", "Learn/JavaScript/Asynchronous/Timeouts_and_intervals", "Learn/JavaScript/Asynchronous")}}</p>

<h2 id="In_this_module">이 모듈의 내용</h2>

<ul>
 <li><a href="/ko/docs/Learn/JavaScript/Asynchronous/Concepts">일반 비동기 프로그래밍 개념</a></li>
 <li><a href="/ko/docs/Learn/JavaScript/Asynchronous/Introducing">비동기 JavaScript 입문</a></li>
 <li><a href="/ko/docs/Learn/JavaScript/Asynchronous/Timeouts_and_intervals">협력하는 비동기 JavaScript: 타임아웃과 인터벌</a></li>
 <li><a href="/ko/docs/Learn/JavaScript/Asynchronous/Promises">프로미스와 함께하는 우아한 비동기 프로그래밍</a></li>
 <li><a href="/ko/docs/Learn/JavaScript/Asynchronous/Async_await">비동기 프로그래밍을 쉽게 만드는 async와 await</a></li>
 <li><a href="/ko/docs/Learn/JavaScript/Asynchronous/Choosing_the_right_approach">올바른 접근 방식 선택하기</a></li>
</ul>
