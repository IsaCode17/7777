---
title: 서버로부터 데이터 가져오기
slug: Learn/JavaScript/Client-side_web_APIs/Fetching_data
tags:
  - API
  - Article
  - Beginner
  - CodingScripting
  - Fetch
  - JSON
  - JavaScript
  - Learn
  - Promises
  - Server
  - XHR
  - XML
  - XMLHttpRequest
  - data
  - request
---

<div>{{LearnSidebar}}</div>

<div>
  {{PreviousMenuNext("Learn/JavaScript/Client-side_web_APIs/Manipulating_documents",
  "Learn/JavaScript/Client-side_web_APIs/Third_party_APIs",
  "Learn/JavaScript/Client-side_web_APIs")}}
</div>

<p class="summary">
  현대 웹사이트와 어플리케이션에서 흔히 있는 또 하나의 작업은 웹사이트의 섹션을
  업데이트하기 위해 새로운 전체 페이지를 로드하는 것이 아니라, 각각의 데이터
  조각들을 서버로부터 가져오는 것입니다. 이 사소해보이는 디테일이 사이트들의
  성능과 동작에 큰 영향을 미쳤습니다. 따라서 우리는 본문에서 이 개념들을
  설명하고 그후 이를 가능하게 해준 XMLHttpRequest, Fetch API 와 같은 기술들에
  대해 살펴보겠습니다.
</p>

<table class="learn-box standard-table">
  <tbody>
    <tr>
      <th scope="row">Prerequisites:</th>
      <td>
        JavaScript basics (see
        <a href="/en-US/docs/Learn/JavaScript/First_steps">first steps</a>,
        <a href="/en-US/docs/Learn/JavaScript/Building_blocks"
          >building blocks</a
        >,
        <a href="/en-US/docs/Learn/JavaScript/Objects">JavaScript objects</a>),
        the
        <a href="/en-US/docs/Learn/JavaScript/Client-side_web_APIs/Introduction"
          >basics of Client-side APIs</a
        >
      </td>
    </tr>
    <tr>
      <th scope="row">Objective:</th>
      <td>
        서버로부터 데이터를 가져오는 방법과 그것으로 웹 페이지 컨텐츠를
        업데이트하는 방법을 배우기
      </td>
    </tr>
  </tbody>
</table>

<h2 id="What_is_the_problem_here">What is the problem here?</h2>

<p>
  본래 웹에서 페이지 로딩은 간단했습니다. 당신이 서버로부터 정상적으로 웹
  페이지를 요청했다면, 웹 페이지를 만드는 자료들이 다운로드되어 당신의 컴퓨터에
  표시될 것입니다.
</p>

<p>
  <img
    alt="A basic representation of a web site architecture"
    src="web-site-architechture@2x.png"
    style="display: block; margin: 0px auto"
  />
</p>

<p>
  이 모델의 문제점은 당신이 페이지의 특정 파트를 업데이트하길 원할 때마다,
  예컨대 새로운 상품들 혹은 새 페이지를 보여줘야 할 때 전체 페이지를 로드해야
  한다는 것이었습니다. 이것은 매우 비효율적이었고 특히 페이지들이 많아지고
  복잡해짐에 따라 열악한 UX를 제공했습니다.
</p>

<h3 id="Enter_Ajax">Enter Ajax</h3>

<p>
  이는 웹 페이지가 작은 데이터 뭉치들(<a href="/en-US/docs/Web/HTML">HTML</a>,
  {{glossary("XML")}},
  <a href="/en-US/docs/Learn/JavaScript/Objects/JSON">JSON</a>, 혹은 plain text
  와 같은)을 요청할 수 있도록 해주며, 그것들을 오직 필요할 때 표시함으로써 앞서
  열거한 문제를 해결하도록 해주는 어떠한 기술의 등장을 야기했습니다.
</p>

<p>
  {{domxref("XMLHttpRequest")}}, 혹은 최근에 등장한
  <a href="/en-US/docs/Web/API/Fetch_API">Fetch API</a> 와 같은 API들이 이것을
  가능하게 해주었습니다. 이 기술들은 서버의 특정 리소스들에 대한
  <a href="/en-US/docs/Web/HTTP">HTTP</a> 요청들을 생성하는 일과 그 결과물들을
  필요할 경우 화면에 표시되기 전에 포맷팅하는 일을 웹 페이지에서 직접적으로
  조작할 수 있도록 해주었습니다.
</p>

<div class="note">
  <p>
    <strong>Note</strong>: 초기에 이러한 기법은
    <a href="/en-US/docs/Glossary/Asynchronous">Asynchronous</a> JavaScript and
    XML (<a href="/en-US/docs/Glossary/AJAX">Ajax</a>) 로 알려졌습니다. 왜냐하면
    이 기술이 주로 XML 데이터를 요청하기 위해 {{domxref("XMLHttpRequest")}} 를
    사용했기 때문입니다. 요즘은 일반적으로 그렇지 않습니다만(<code
      >XMLHttpRequest</code
    >
    혹은 Fetch 로 JSON을 요청하는 경우가 더 많습니다), 그 결과물은 여전히
    동일하며 "Ajax" 라는 용어는 여전히 이 기술을 묘사하는데 사용됩니다.
  </p>
</div>

<p>
  <img
    alt="A simple modern architecture for web sites"
    src="moderne-web-site-architechture@2x.png"
    style="display: block; margin: 0px auto"
  />
</p>

<p>
  Ajax 모델의 핵심은 하나의 웹 API 를 프록시로서 사용함으로써 전체 페이지를 다시
  로드하는 방식보다 더 현명하게 데이터를 요청한다는 것입니다. 이것이 얼마나
  중요한 일인지 생각해봅시다:
</p>

<ol>
  <li>
    아마존, 유튜브, CNN 등 당신이 애용하는 정보량이 많은 사이트 중 하나에 가셔서
    그것을 로드해보세요.
  </li>
  <li>
    아무거나 검색해보세요, 예를 들어 신제품을 검색해볼 수 있겠죠. 메인 컨텐츠는
    바뀌겠지만, 헤더, 푸터, 네비게이션 메뉴와 같은 주변 정보들 대부분은 여전히
    같을 것입니다.
  </li>
</ol>

<p>이는 매우 좋은 일입니다 왜냐하면:</p>

<ul>
  <li>
    페이지 업데이트가 훨씬 빨라지며 당신은 페이지가 새로고침될 때까지 기다릴
    필요가 없습니다. 즉 사이트가 더 빠르며 반응적이라고 느끼게 해줍니다.
  </li>
  <li>
    매 업데이트마다 적은 양의 데이터가 다운로드 됩니다, 즉 대역폭이 덜
    낭비됩니다. 데스크탑이 브로드밴드에 연결되어 있다면 이것이 큰 이슈가 아닐 수
    있습니다. 하지만 모바일 기기와 빠른 속도의 유비쿼터스 인터넷 서비스를 이용할
    수 없는 개발도상국에서 이는 중요한 이슈입니다.
  </li>
</ul>

<p>
  속도를 더욱 빠르게 하기 위해 일부 사이트들은 유저가 처음 요청했을 때 자료와
  데이터를 유저의 컴퓨터에 저장하기도 합니다. 이렇게 함으로써 연속해서
  방문했을때, 첫 페이지 로드가 로드될 때마다 새로운 사본을 다운로드 받는 것이
  아니라 기존 로컬에 있는 버전을 사용할 수 있게 됩니다. 그 컨텐츠가 업데이트 된
  경우에만 서버에서 리로드됩니다.
</p>

<p>
  <img
    alt="A basic web app data flow architecture"
    src="web-app-architecture@2x.png"
    style="display: block; margin: 0px auto"
  />
</p>

<h2 id="A_basic_Ajax_request">A basic Ajax request</h2>

<p>
  {{domxref("XMLHttpRequest")}}와
  <a href="/en-US/docs/Web/API/Fetch_API">Fetch</a>를 사용하여 요청을 다루는
  방법을 알아봅시다. 뒤의 예제들에서 우리는 몇몇의 다른 텍스트 파일들로부터
  데이터를 요청하고 그것을 사용하여 컨텐츠 영역을 채울 것입니다.
</p>

<p>
  일련의 파일들은 우리의 가짜 데이터베이스로서 역할을 할 것입니다; 실제
  어플리케이션에서는 PHP, Python, 혹은 Node와 같은 서버 측 언어를 사용하여
  데이터베이스로부터 데이터를 요청할 경우가 더 일반적일 것입니다.
</p>

<h3 id="XMLHttpRequest">XMLHttpRequest</h3>

<p>
  <code>XMLHttpRequest</code> (주로 줄여서 XHR) 은 꽤 오래된 기술입니다. 이
  기술은 Mircrosoft가 1990년 후반에 발표했고, 꽤 오랫동안 브라우저 전반에 걸쳐
  표준이 되었습니다.
</p>

<ol>
  <li>
    <p>
      이 예제를 시작하기 위해
      <a
        href="https://github.com/mdn/learning-area/blob/master/javascript/apis/fetching-data/ajax-start.html"
        >ajax-start.html</a
      >
      과 네 가지 텍스트 파일들
      <a
        href="https://github.com/mdn/learning-area/blob/master/javascript/apis/fetching-data/verse1.txt"
        >verse1.txt</a
      >,
      <a
        href="https://github.com/mdn/learning-area/blob/master/javascript/apis/fetching-data/verse2.txt"
        >verse2.txt</a
      >,
      <a
        href="https://github.com/mdn/learning-area/blob/master/javascript/apis/fetching-data/verse3.txt"
        >verse3.txt</a
      >,
      <a
        href="https://github.com/mdn/learning-area/blob/master/javascript/apis/fetching-data/verse4.txt"
        >verse4.txt</a
      >
      의 로컬 사본을 당신의 컴퓨터 새로운 디렉토리에 만드세요. 이번 예제에서
      우리는 drop-down 메뉴에서 시(당신이 이미 알고 있을 수도 있는)의 다른
      구절들이 선택되었을 때 이를 XHR을 통해 로드할 것입니다.
    </p>
  </li>
  <li>
    <p>
      {{htmlelement("script")}} 엘리먼트 내부에 다음의 코드를 넣어주세요.
      {{htmlelement("select")}}와 {{htmlelement("pre")}} 엘리먼트의 레퍼런스를
      constant 변수들에 저장하는 코드입니다. 그리고
      {{domxref("GlobalEventHandlers.onchange","onchange")}} 이벤트 핸들러
      함수를 정의함으로써 select의 값이 변경되었을 때, 그 값이 호출된 함수
      <code>updateDisplay()</code>의 매개변수로 전달되도록 해주세요.
    </p>

    <pre class="brush: js">
const verseChoose = document.querySelector('select');
const poemDisplay = document.querySelector('pre');

verseChoose.onchange = function() {
  const verse = verseChoose.value;
  updateDisplay(verse);
};</pre
    >
  </li>
  <li>
    <p>
      이제 <code>updateDisplay()</code> 함수를 정의해봅시다. 가장 먼저 이전 코드
      블럭 아래에 다음 코드(내부가 비어있는 함수)를 넣어주세요. Note: 4 -
      9단게는 이 함수 내부에서 수행될 것입니다.
    </p>

    <pre class="brush: js">
function updateDisplay(verse) {

}</pre
    >
  </li>
  <li>
    <p>
      함수를 작성하기 앞서 나중에 필요한 텍스트 파일을 로드하기 위한 파일의
      상대경로를 정의합시다. {{htmlelement("select")}} 엘리먼트의 내부는 언제나
      선택된 {{htmlelement("option")}} 로 같습니다 (만약 당신이 어떤 값을
      속성으로 명시하지 않았다면요) - 예를 들어 "Verse 1"일 수 있습니다. 구절에
      해당되는 텍스트 파일은 "verse1.txt" 이며 HTML 파일과 동일한 디렉토리에
      있으므로 파일 이름만으로도 동일하게 동작할 것입니다.
    </p>

    <p>
      하지만 웹 서버는 대소문자를 구분하며, 파일 이름에는 공백도 없습니다.
      "Verse 1"을 "verse1.txt" 로 변환하기 위해 V를 소문자로 변경하고, 공백을
      제거 한뒤, .txt 를 끝에 추가해야 합니다. {{jsxref("String.replace",
      "replace()")}}, {{jsxref("String.toLowerCase", "toLowerCase()")}}, 그리고
      간단한
      <a
        href="/en-US/docs/Learn/JavaScript/First_steps/Strings#concatenating_strings"
        >string concatenation</a
      >
      이면 될 겁니다. 다음 코드 라인들을 당신의
      <code>updateDisplay()</code> 함수 내부에 추가하세요:
    </p>

    <pre class="brush: js">
verse = verse.replace(" ", "");
verse = verse.toLowerCase();
let url = verse + '.txt';</pre
    >
  </li>
  <li>
    <p>
      XHF 요청을 만들기 위해서 {{domxref("XMLHttpRequest.XMLHttpRequest",
      "XMLHttpRequest()")}} 생성자를 이용해 요청 객체를 만들어야 합니다. 객체의
      이름은 원하는대로 호출할 수 있겠지만, 간단히 하기 위해
      <code>request</code>라 합시다. 아래 코드를 당신의
      <code>updateDisplay()</code> 함수 내부에 추가하세요:
    </p>

    <pre class="brush: js">let request = new XMLHttpRequest();</pre>
  </li>
  <li>
    <p>
      이제 당신은 네트워크로 자원을 가져오기 위해 어떤
      <a href="/en-US/docs/Web/HTTP/Methods">HTTP request method</a>를
      사용할지와 그것의 URL은 어떻게 되는지 명시하기 위해
      {{domxref("XMLHttpRequest.open","open()")}} 메서드를 이용해야 합니다.
      우리는 여기서
      <code><a href="/en-US/docs/Web/HTTP/Methods/GET">GET</a></code> method
      만을 사용할겁니다. 그리고 URL 을 우리의 <code>url</code> 변수로 설정해놓을
      거에요. 아래를 이전 코드에 추가하세요:
    </p>

    <pre class="brush: js">request.open('GET', url);</pre>
  </li>
  <li>
    <p>
      다음으로 우리는 응답받길 기대하는 타입을 <code>text</code>로 설정합니다.
      요청의 {{domxref("XMLHttpRequest.responseType", "responseType")}} 속성에서
      이것이 정의됩니다. 이것은 이곳에 반드시 필요한 건 아닙니다. XHR 이
      디폴트로 text를 리턴하거든요. 하지만 나중에 다른 유형의 데이터를 가져오고
      싶을 수도 있으므로 타입을 설정하는 습관을 들이는 것이 좋습니다. 다음을
      추가하세요:
    </p>

    <pre class="brush: js">request.responseType = 'text';</pre>
  </li>
  <li>
    <p>
      네트워크를 거쳐 자원을 가져오는 일은 {{glossary("asynchronous")}}
      작업입니다. 즉 당신이 해당 응답으로 무언가를 하기 전에, 그 작업이 끝날
      때까지 (자원이 네트워크를 거쳐 반환될 때까지) 기다려야 한다는 의미입니다.
      그렇지 않으면 오류가 발생합니다. XHR은 {{domxref("XMLHttpRequest.onload",
      "onload")}} 이벤트 핸들러를 이용해 이러한 상황을 처리할 수 수 있도록
      해줍니다. 이것은 {{event("load")}} 이벤트가 발생했을 때(응답이 반환되었을
      때) 실행됩니다. 이 경우에 응답 데이터는 XHR 요청 객체의
      <code>response</code> 속성에서 사용 가능합니다.
    </p>

    <p>
      다음 코드들을 마지막으로 추가했던 코드에 추가하세요. 당신은
      <code>onload</code> 이벤트 핸들러 내부에서 우리가
      <code>poemDisplay</code>({{htmlelement("pre")}}의 엘리먼트)의
      <code><a href="/en-US/docs/Web/API/Node/textContent">textContent</a></code
      >를 {{domxref("XMLHttpRequest.response", "request.response")}}의 속성
      값으로 설정하고 있음을 확인할 수 있습니다.
    </p>

    <pre class="brush: js">
request.onload = function() {
  poemDisplay.textContent = request.response;
};</pre
    >
  </li>
  <li>
    <p>
      지금까지는 모두 XHR 요청을 위한 설정들이어었습니다. 사실 이것은 우리가
      {{domxref("XMLHttpRequest.send","send()")}} 메서드를 사용하여 요청이
      완료되었다고 알려주기 전까지 동작하지 않습니다. 아래 코드를 이전까지의
      코드에 추가하여 함수를 완성하세요. 이 코드 줄은
      <code>updateDisplay()</code> 함수의 닫히는 brace 바로 위에 놓여야 합니다.
    </p>

    <pre class="brush: js">request.send();</pre>
  </li>
  <li>
    <p>
      위 예제의 한 가지 문제점은 이것이 처음 로드되었을 때 어떤 시도 보여주지
      않는다는 것입니다. 이 문제를 고치기 위해, 코드 하단(<code
        >&lt;/script&gt;</code
      >
      태그가 닫히는 바로 위)에 다음 두 줄의 코드를 추가함으로써 첫 번째 구절이
      디폴트로 로드되게 하세요. 그리고 {{htmlelement("select")}}가 항상 올바른
      값을 로드하는지 확인하세요:
    </p>

    <pre class="brush: js">
updateDisplay('Verse 1');
verseChoose.value = 'Verse 1';</pre
    >
  </li>
</ol>

<h3 id="Serving_your_example_from_a_server">
  Serving your example from a server
</h3>

<p>
  만약 당신이 위 예제처럼 로컬 파일만을 처리한다면, 최신 브라우저들은 XHR 요청을
  처리하지 않을 것입니다. 이것은 보안 제약들 때문입니다. (더 많은 웹 보안은
  다음을 읽어보세요
  <a href="/en-US/docs/Learn/Server-side/First_steps/Website_security"
    >Website security</a
  >)).
</p>

<p>
  이 문제를 해결하기 위해, 로컬 웹 서버에서 예제를 테스트해야 합니다. 이 작업을
  수행하는 방법을 알아보려면
  <a href="/en-US/docs/Learn/Common_questions/set_up_a_local_testing_server"
    >로컬 테스팅 서버를 어떻게 설정하나요?</a
  >를 읽어보세요.
</p>

<h3 id="Fetch">Fetch</h3>

<p>
  Fetch API는 기본적으로 XHR을 대체하기 위해 최근에 등장한 기술입니다; 이는 최신
  브라우저에 도입되었으며 이를 통해 개발자와 Fetch를 기반으로 구축되는 다른
  API들 모두 더 쉽게 자바스크립트로 비동기 HTTP 요청을 할 수 있게 되었습니다.
</p>

<p>XHR 대신 Fetch를 사용하도록 마지막 예제를 수정해봅시다.</p>

<ol>
  <li>
    <p>
      이전에 완료한 예제 디렉토리의 복사본을 만드세요. (만약 이전 예제를
      수행하지 않았다면, 새로운 디렉토리를 만들고 그 안에
      <a
        href="https://github.com/mdn/learning-area/blob/master/javascript/apis/fetching-data/xhr-basic.html"
        >xhr-basic.html</a
      >
      과 4개의 텍스트 파일
      <a
        href="https://github.com/mdn/learning-area/blob/master/javascript/apis/fetching-data/verse1.txt"
        >verse1.txt</a
      >,
      <a
        href="https://github.com/mdn/learning-area/blob/master/javascript/apis/fetching-data/verse2.txt"
        >verse2.txt</a
      >,
      <a
        href="https://github.com/mdn/learning-area/blob/master/javascript/apis/fetching-data/verse3.txt"
        >verse3.txt</a
      >,
      <a
        href="https://github.com/mdn/learning-area/blob/master/javascript/apis/fetching-data/verse4.txt"
        >verse4.txt</a
      >
      의 복사본을 만드세요.)
    </p>
  </li>
  <li>
    <p><code>updateDisplay()</code> 함수 내부에서 XHR 코드를 찾으세요:</p>

    <pre class="brush: js">
let request = new XMLHttpRequest();
request.open('GET', url);
request.responseType = 'text';

request.onload = function() {
  poemDisplay.textContent = request.response;
};

request.send();</pre
    >
  </li>
  <li>
    <p>XHR 코드를 다음처럼 변경하세요:</p>

    <pre class="brush: js">
fetch(url).then(function(response) {
  response.text().then(function(text) {
    poemDisplay.textContent = text;
  });
});</pre
    >
  </li>
  <li>
    <p>
      예제를 브라우저에서 로드하세요(웹 서버를 통해 실행). 당신이 최신
      브라우저를 사용 중이라면, XHR 버전과 동일하게 동작합니다.
    </p>
  </li>
</ol>

<h4 id="So_what_is_going_on_in_the_Fetch_code">
  So what is going on in the Fetch code?
</h4>

<p>
  먼저 가져올 리소스의 URL을 전달하여
  {{domxref("WorkerOrWindowGlobalScope.fetch()","fetch()")}} 메서드를
  호출합니다. 이것은 XHR에서 {{domxref("XMLHttpRequest.open","request.open()")}}
  에 해당되는 모던한 방식이며, XHR에서처럼 <code>.send()</code>이 필요하지
  않습니다.
</p>

<p>
  그러면 당신은 {{jsxref("Promise.then",".then()")}} 메서드가
  <code>fetch()</code> 끝에 체이닝된 것을 확인할 수 있습니다. -
  <code>.then()</code> 메서드는 비동기 처리를 위한 최신 Javascript 기술인
  {{jsxref("Promise","Promises")}}를 위한 부분입니다. <code>fetch()</code>는
  <a href="/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise"
    >promise</a
  >를 반환하며, 이 promise는 서버로부터 응답을 받음으로써 resolve 됩니다. 우리는
  promise 가 resolve 된 후 내부에 정의해놓은 후속 함수 코드를 실행하기 위해
  <code>.then()</code>을 사용합니다. 이런 방식으로 XHR의
  <code>onload</code> 이벤트 핸들러를 대체할 수 있습니다.
</p>

<p>
  이 함수는 <code>fetch()</code> promise 가 resolve 됐을 때, 자동으로 서버로부터
  받는 응답의 매개변수로 제공됩니다. 이 함수 내부에서 우리는 응답을 붙잡고,
  응답을 기본적으로 원시 텍스트로 반환하는 {{domxref("Body.text","text()")}}를
  실행합니다. 이 방식은 XHR의 <code>request.responseType = 'text'</code> 부분을
  대체합니다.
</p>

<p>
  <code>text()</code> 도 proimse를 반환합니다. 또 다른 <code>.then()</code>을 그
  promise에 체이닝하고 그 내부에서 <code>text()</code> proimse가 resolve 됐을 때
  원시 텍스트 데이터를 받는 함수를 정의합니다.
</p>

<p>
  우리는 proimse의 함수 내부에서 XHR에서 했던 것과 유사한 작업을 수행합니다. 즉,
  {{htmlelement("pre")}} 엘리먼트의 textContent에 텍스트 값을 설정합니다.
</p>

<h3 id="Aside_on_promises">Aside on promises</h3>

<p>
  Promises are a bit confusing the first time you meet them, but don't worry too
  much about this for now. You'll get used to them after a while, especially as
  you learn more about modern JavaScript APIs — most of the newer ones are
  heavily based on promises.
</p>

<p>
  Let's look at the promise structure from above again to see if we can make
  some more sense of it:
</p>

<pre class="brush: js">
fetch(url).then(function(response) {
  response.text().then(function(text) {
    poemDisplay.textContent = text;
  });
});</pre
>

<p>
  The first line is saying "fetch the resource located at URL"
  (<code>fetch(url)</code>) and "then run the specified function when the
  promise resolves" (<code>.then(function() { ... })</code>). "Resolve" means
  "finish performing the specified operation at some point in the future". The
  specified operation, in this case, is to fetch a resource from a specified URL
  (using an HTTP request), and return the response for us to do something with.
</p>

<p>
  Effectively, the function passed into <code>then()</code> is a chunk of code
  that won't run immediately. Instead, it will run at some point in the future
  when the response has been returned. Note that you could also choose to store
  your promise in a variable and chain {{jsxref("Promise.then",".then()")}} onto
  that instead. The code below would do the same thing:
</p>

<pre class="brush: js">
let myFetch = fetch(url);

myFetch.then(function(response) {
  response.text().then(function(text) {
    poemDisplay.textContent = text;
  });
});</pre
>

<p>
  Because the <code>fetch()</code> method returns a promise that resolves to the
  HTTP response, any function you define inside a <code>.then()</code> chained
  onto the end of it will automatically be given the response as a parameter.
  You can call the parameter anything you like — the below example would still
  work:
</p>

<pre class="brush: js">
fetch(url).then(function(dogBiscuits) {
  dogBiscuits.text().then(function(text) {
    poemDisplay.textContent = text;
  });
});</pre
>

<p>
  But it makes more sense to call the parameter something that describes its
  contents.
</p>

<p>Now let's focus just on the function:</p>

<pre class="brush: js">
function(response) {
  response.text().then(function(text) {
    poemDisplay.textContent = text;
  });
}</pre
>

<p>
  The response object has a method {{domxref("Body.text","text()")}} that takes
  the raw data contained in the response body and turns it into plain text — the
  format we want it in. It also returns a promise (which resolves to the
  resulting text string), so here we use another
  {{jsxref("Promise.then",".then()")}}, inside of which we define another
  function that dictates what we want to do with that text string. We are just
  setting the
  <code><a href="/en-US/docs/Web/API/Node/textContent">textContent</a></code>
  property of our poem's {{htmlelement("pre")}} element to equal the text
  string, so this works out pretty simple.
</p>

<p>
  It is also worth noting that you can directly chain multiple promise blocks
  (<code>.then()</code> blocks, but there are other types too) onto the end of
  one another, passing the result of each block to the next block as you travel
  down the chain. This makes promises very powerful.
</p>

<p>
  The following block does the same thing as our original example, but is
  written in a different style:
</p>

<pre class="brush: js">
fetch(url).then(function(response) {
  return response.text()
}).then(function(text) {
  poemDisplay.textContent = text;
});</pre
>

<p>
  Many developers like this style better, as it is flatter and arguably easier
  to read for longer promise chains — each subsequent promise comes after the
  previous one, rather than being inside the previous one (which can get
  unwieldy). The only other difference is that we've had to include a
  <code
    ><a href="/en-US/docs/Learn/JavaScript/Building_blocks/Return_values"
      >return</a
    ></code
  >
  statement in front of <code>response.text()</code>, to get it to pass its
  result on to the next link in the chain.
</p>

<h3 id="Which_mechanism_should_you_use">Which mechanism should you use?</h3>

<p>
  This really depends on what project you are working on. XHR has been around
  for a long time now and has very good cross-browser support. Fetch and
  Promises, on the other hand, are a more recent addition to the web platform,
  although they're supported well across the browser landscape, with the
  exception of Internet Explorer.
</p>

<p>
  If you need to support older browsers, then an XHR solution might be
  preferable. If however you are working on a more progressive project and
  aren't as worried about older browsers, then Fetch could be a good choice.
</p>

<p>
  You should really learn both — Fetch will become more popular as Internet
  Explorer declines in usage (IE is no longer being developed, in favor of
  Microsoft's new Edge browser), but you might need XHR for a while yet.
</p>

<h2 id="A_more_complex_example">A more complex example</h2>

<p>
  To round off the article, we'll look at a slightly more complex example that
  shows some more interesting uses of Fetch. We have created a sample site
  called The Can Store — it's a fictional supermarket that only sells canned
  goods. You can find this
  <a
    href="https://mdn.github.io/learning-area/javascript/apis/fetching-data/can-store/"
    >example live on GitHub</a
  >, and
  <a
    href="https://github.com/mdn/learning-area/tree/master/javascript/apis/fetching-data/can-store"
    >see the source code</a
  >.
</p>

<p>
  <img
    alt="A fake ecommerce site showing search options in the left hand column, and product search results in the right hand column."
    src="can-store.png"
    style="display: block; margin: 0 auto"
  />
</p>

<p>
  By default, the site displays all the products, but you can use the form
  controls in the left hand column to filter them by category, or search term,
  or both.
</p>

<p>
  There is quite a lot of complex code that deals with filtering the products by
  category and search terms, manipulating strings so the data displays correctly
  in the UI, etc. We won't discuss all of it in the article, but you can find
  extensive comments in the code (see
  <a
    href="https://github.com/mdn/learning-area/blob/master/javascript/apis/fetching-data/can-store/can-script.js"
    >can-script.js</a
  >).
</p>

<p>We will however explain the Fetch code.</p>

<p>
  The first block that uses Fetch can be found at the start of the JavaScript:
</p>

<pre class="brush: js">
fetch('products.json').then(function(response) {
  return response.json();
}).then(function(json) {
  let products = json;
  initialize(products);
}).catch(function(err) {
  console.log('Fetch problem: ' + err.message);
});</pre
>

<p>
  The <code>fetch()</code> function returns a promise. If this completes
  successfully, the function inside the first <code>.then()</code> block
  contains the <code>response</code> returned from the network.
</p>

<p>
  Inside this function we run {{domxref("Body.json","json()")}} on the response,
  not {{domxref("Body.text","text()")}}, as we want to return our response as
  structured JSON data, not plain text.
</p>

<p>
  Next, we chain another <code>.then()</code> onto the end of our first one, the
  success function that contains the <code>json</code> returned from the
  <code>response.json()</code> promise. We set this to be the value of the
  <code>products</code> variable, then run <code>initialize(products)</code>,
  which starts the process of displaying all the products in the user interface.
</p>

<p>
  To handle errors, we chain a <code>.catch()</code> block onto the end of the
  chain. This runs if the promise fails for some reason. Inside it, we include a
  function that is passed as a parameter, an <code>error</code> object.
  This <code>error</code> object can be used to report the nature of the error
  that has occurred, in this case we do it with a simple
  <code>console.log()</code>.
</p>

<p>
  However, a complete website would handle this error more gracefully by
  displaying a message on the user's screen and perhaps offering options to
  remedy the situation, but we don't need anything more than a simple
  <code>console.log()</code>.
</p>

<p>You can test the fail case yourself:</p>

<ol>
  <li>
    Make a local copy of the example files (download and unpack
    <a
      href="https://github.com/mdn/learning-area/blob/master/javascript/apis/fetching-data/can-store/can-store.zip?raw=true"
      >the can-store ZIP file</a
    >).
  </li>
  <li>
    Run the code through a web server (as described above, in {{anch("Serving
    your example from a server")}}).
  </li>
  <li>
    Modify the path to the file being fetched, to something like 'produc.json'
    (make sure it is misspelled).
  </li>
  <li>
    Now load the index file in your browser (via <code>localhost:8000</code>)
    and look in your browser developer console. You'll see a message similar to
    "Network request for produc.json failed with response 404: File not found".
  </li>
</ol>

<p>
  The second Fetch block can be found inside the
  <code>fetchBlob()</code> function:
</p>

<pre class="brush: js">
fetch(url).then(function(response) {
    return response.blob();
}).then(function(blob) {
  // Convert the blob to an object URL — this is basically a temporary internal URL
  // that points to an object stored inside the browser
  let objectURL = URL.createObjectURL(blob);
  // invoke showProduct
  showProduct(objectURL, product);
});</pre
>

<p>
  This works in much the same way as the previous one, except that instead of
  using {{domxref("Body.json","json()")}}, we use
  {{domxref("Body.blob","blob()")}}. In this case we want to return our response
  as an image file, and the data format we use for that is
  <a href="/en-US/docs/Web/API/Blob">Blob</a> (the term is an abbreviation of
  "Binary Large Object" and can basically be used to represent large file-like
  objects, such as images or video files).
</p>

<p>
  Once we've successfully received our blob, we create an object URL out of it
  using {{domxref("URL.createObjectURL()", "createObjectURL()")}}. This returns
  a temporary internal URL that points to an object referenced inside the
  browser. These are not very readable, but you can see what one looks like by
  opening up the Can Store app, Ctrl-/Right-clicking on an image, and selecting
  the "View image" option (which might vary slightly depending on what browser
  you are using). The object URL will be visible inside the address bar, and
  should be something like this:
</p>

<pre>blob:http://localhost:7800/9b75250e-5279-e249-884f-d03eb1fd84f4</pre>

<h3 id="Challenge_An_XHR_version_of_the_Can_Store">
  Challenge: An XHR version of the Can Store
</h3>

<p>
  We'd like you to try converting the Fetch version of the app to use XHR as a
  useful bit of practice. Take a
  <a
    href="https://github.com/mdn/learning-area/blob/master/javascript/apis/fetching-data/can-store/can-store.zip?raw=true"
    >copy of the ZIP file</a
  >, and try modifying the JavaScript as appropriate.
</p>

<p>Some helpful hints:</p>

<ul>
  <li>
    You might find the {{domxref("XMLHttpRequest")}} reference material useful.
  </li>
  <li>
    You will basically need to use the same pattern as you saw earlier in the
    <a
      href="https://github.com/mdn/learning-area/blob/master/javascript/apis/fetching-data/xhr-basic.html"
      >XHR-basic.html</a
    >
    example.
  </li>
  <li>
    You will, however, need to add the error handling we showed you in the Fetch
    version of the Can Store:
    <ul>
      <li>
        The response is found in <code>request.response</code> after the
        <code>load</code> event has fired, not in a promise <code>then()</code>.
      </li>
      <li>
        About the best equivalent to Fetch's <code>response.ok</code> in XHR is
        to check whether {{domxref("XMLHttpRequest.status","request.status")}}
        is equal to 200, or if
        {{domxref("XMLHttpRequest.readyState","request.readyState")}} is equal
        to 4.
      </li>
      <li>
        The properties for getting the status and status message are the same,
        but they are found on the <code>request</code> (XHR) object, not the
        <code>response</code> object.
      </li>
    </ul>
  </li>
</ul>

<div class="note">
  <p>
    <strong>Note</strong>: If you have trouble with this, feel free to check
    your code against the finished version on GitHub (<a
      href="https://github.com/mdn/learning-area/blob/master/javascript/apis/fetching-data/can-store-xhr/can-script.js"
      >see the source here</a
    >, and also
    <a
      href="https://mdn.github.io/learning-area/javascript/apis/fetching-data/can-store-xhr/"
      >see it running live</a
    >).
  </p>
</div>

<h2 id="Summary">Summary</h2>

<p>
  This article shows how to start working with both XHR and Fetch to fetch data
  from the server.
</p>

<h2 id="See_also">See also</h2>

<p>
  There are however a lot of different subjects discussed in this article, which
  has only really scratched the surface. For a lot more detail on these
  subjects, try the following articles:
</p>

<ul>
  <li>
    <a href="/en-US/docs/Web/Guide/AJAX/Getting_Started"
      >Ajax — Getting started</a
    >
  </li>
  <li><a href="/en-US/docs/Web/API/Fetch_API/Using_Fetch">Using Fetch</a></li>
  <li>
    <a href="/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise"
      >Promises</a
    >
  </li>
  <li>
    <a href="/en-US/docs/Learn/JavaScript/Objects/JSON"
      >Working with JSON data</a
    >
  </li>
  <li><a href="/en-US/docs/Web/HTTP/Overview">An overview of HTTP</a></li>
  <li>
    <a href="/en-US/docs/Learn/Server-side">Server-side website programming</a>
  </li>
</ul>

<div>
  {{PreviousMenuNext("Learn/JavaScript/Client-side_web_APIs/Manipulating_documents",
  "Learn/JavaScript/Client-side_web_APIs/Third_party_APIs",
  "Learn/JavaScript/Client-side_web_APIs")}}
</div>

<h2 id="In_this_module">In this module</h2>

<ul>
  <li>
    <a href="/en-US/docs/Learn/JavaScript/Client-side_web_APIs/Introduction"
      >Introduction to web APIs</a
    >
  </li>
  <li>
    <a
      href="/en-US/docs/Learn/JavaScript/Client-side_web_APIs/Manipulating_documents"
      >Manipulating documents</a
    >
  </li>
  <li>
    <a href="/en-US/docs/Learn/JavaScript/Client-side_web_APIs/Fetching_data"
      >Fetching data from the server</a
    >
  </li>
  <li>
    <a href="/en-US/docs/Learn/JavaScript/Client-side_web_APIs/Third_party_APIs"
      >Third party APIs</a
    >
  </li>
  <li>
    <a href="/en-US/docs/Learn/JavaScript/Client-side_web_APIs/Drawing_graphics"
      >Drawing graphics</a
    >
  </li>
  <li>
    <a
      href="/en-US/docs/Learn/JavaScript/Client-side_web_APIs/Video_and_audio_APIs"
      >Video and audio APIs</a
    >
  </li>
  <li>
    <a
      href="/en-US/docs/Learn/JavaScript/Client-side_web_APIs/Client-side_storage"
      >Client-side storage</a
    >
  </li>
</ul>
