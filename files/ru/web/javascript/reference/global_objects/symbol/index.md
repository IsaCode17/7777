---
title: Symbol
slug: Web/JavaScript/Reference/Global_Objects/Symbol
---

{{JSRef}}

**`Symbol`** — это встроенный объект, конструктор которого возвращает значение [примитивного типа](/ru/docs/Glossary/Primitive) `symbol`. Такие значения называют **символьными значениями** (**Symbol value**) или просто **символами** (**Symbol**), их основная особенность в том, что они гарантируют уникальность. Символы часто используются в качестве уникальных ключей объекта. Они не пересекаются с ключами, которые могут быть добавлены другим кодом, а также скрыты от доступа из другого кода. Это обеспечивает возможность слабой {{Glossary("encapsulation", "инкапсуляции")}} или слабую форму [сокрытия информации](<https://ru.wikipedia.org/wiki/Сокрытие_(программирование)>).

Каждый вызов `Symbol()` гарантированно возвращает уникальный символ. Каждый вызов `Symbol.for("key")` всегда будет возвращать один и тот же символ для указанного значения `"key"`. При вызове `Symbol.for("key")` осуществляется поиск в глобальном реестре символов. Если символ найден, то он возвращается, в противном случае создаётся новый символ, добавляется в глобальный реестр под заданным ключом и возвращается.

## Описание

Чтобы создать новое символьное значение, достаточно написать `Symbol()`, указав по желанию строку в качестве описания:

```js
const sym1 = Symbol();
const sym2 = Symbol("foo");
const sym3 = Symbol("foo");
```

Код выше создаёт три новых символа. Обратите внимание, что `Symbol("foo")` не выполняет приведение строки "foo" к символу. Это выражение создаёт каждый раз новый символ:

```js
Symbol("foo") === Symbol("foo"); // false
```

Код ниже с оператором {{jsxref("Operators/new", "new")}} вызовет исключение {{jsxref("TypeError")}}:

```js example-bad
const sym = new Symbol(); // TypeError
```

Это удерживает разработчиков от создания явного объекта-обёртки `Symbol` вместо нового символьного значения, но может быть неожиданным, так как создание явных объектов-обёрток для примитивных типов доступно (например, `new Boolean`, `new String`, `new Number`).

Если действительно необходимо обернуть символ в объект, можно использовать функцию `Object()`:

```js
const sym = Symbol("foo");
typeof sym; // "symbol"
const symObj = Object(sym);
typeof symObj; // "object"
```

Поскольку символы — единственный примитивный тип данных, который имеет ссылочную идентичность (то есть нельзя создать один и тот же символ дважды), они в некотором смысле ведут себя как объекты. Например, они подлежат сборке мусора и поэтому могут храниться в {{jsxref("WeakMap")}}, {{jsxref("WeakSet")}}, {{jsxref("WeakRef")}} и {{jsxref("FinalizationRegistry")}}.

### Разделяемые символы в глобальном реестре символов

Приведённый выше синтаксис использования функции `Symbol()` создаёт символ, значение которого будет уникальным на протяжении всего времени существования программы. Чтобы создавать символы, доступные в разных файлах и даже областях видимости, можно использовать методы {{jsxref("Symbol.for()")}} и {{jsxref("Symbol.keyFor()" )}} для установки и получения символов из глобального реестра символов.

Обратите внимание, что «глобальный реестр символов» это всего лишь концепция и может не соответствовать какой-либо внутренней структуре данных в движке JavaScript, и даже если такой реестр существует, его содержимое недоступно для кода JavaScript, кроме как через методы `for()` и `keyFor()`.

Метод `Symbol.for(tokenString)` принимает строковый ключ и возвращает символьное значение из реестра, а метод `Symbol.keyFor(symbolValue)` принимает символьное значение и возвращает соответствующий ему строковый ключ. Каждый из них является обратным другому, поэтому следующее выражение истинно:

```js
Symbol.keyFor(Symbol.for("tokenString")) === "tokenString"; // true
```

Поскольку зарегистрированные символы могут быть созданы в произвольном месте, они ведут себя почти так же, как строки, которые они оборачивают, их уникальность не гарантируется они не подлежат сборке мусора. Поэтому зарегистрированные символы нельзя использовать в {{jsxref("WeakMap")}}, {{jsxref("WeakSet")}}, {{jsxref("WeakRef")}} и {{jsxref("FinalizationRegistry")}}.

### Поиск символьных свойств у объектов

Метод {{jsxref("Object.getOwnPropertySymbols()")}} возвращает массив символов и позволяет получить символьные свойства конкретного объекта. Следует заметить, что при инициализации объекты не получают символьных свойств, так что этот массив будет пуст, пока вы не зададите ему какое-либо символьное свойство.

## Свойства

- `Symbol.length`
  - : Содержит длину, всегда равную 0 (нулю).
- {{jsxref("Symbol.prototype")}}
  - : Содержит прототип конструктора `Symbol`.

### Известные символы

В добавок к вашим собственным символам, JavaScript имеет несколько встроенных символов, представляющих внутренние механизмы языка, которые не были доступны разработчикам в версиях ECMAScript 5 и более ранних. Эти символы доступны посредством следующих свойств:

#### Итерационные символы

- {{jsxref("Symbol.iterator")}}

  - : Метод, возвращающий итератор по умолчанию для объекта. Используется конструкцией {{jsxref("Statements/for...of","for...of")}}.

#### Символы регулярных выражений

- {{jsxref("Symbol.match")}}

  - : Метод для сопоставления объекта со строкой, также используемый для определения возможности объекта выступать в качестве регулярного выражения. Используется функцией {{jsxref("String.prototype.match()")}}.

- {{jsxref("Symbol.replace")}}
  - : Метод, заменяющий совпавшие подстроки в строке. Используется функцией {{jsxref("String.prototype.replace()")}}.
- {{jsxref("Symbol.search")}}
  - : Метод, возвращающий индекс вхождения подстроки, соответствующей регулярному выражению. Используется функцией {{jsxref("String.prototype.search()")}}.
- {{jsxref("Symbol.split")}}
  - : Метод, разбивающий строку на части в местах, соответствующих регулярному выражению. Используется функцией {{jsxref("String.prototype.split()")}}.

#### Другие символы

- {{jsxref("Symbol.hasInstance")}}

  - : Метод, определяющий, распознает ли конструктор некоторый объект как свой экземпляр. Используется оператором {{jsxref("Operators/instanceof", "instanceof")}}.

- {{jsxref("Symbol.isConcatSpreadable")}}
  - : Булево значение, показывающее, должен ли объект быть сведён к плоскому представлению (англ. flatten) в виде массива его элементов функцией {{jsxref("Array.prototype.concat()")}}.
- {{jsxref("Symbol.unscopables")}}
  - : Массив строковых имён свойств. Позволяет скрыть свойства от инструкции with (прежде всего для обратной совместимости).
- {{jsxref("Symbol.species")}}
  - : Метод, определяющий конструктор для порождённых объектов.
- {{jsxref("Symbol.toPrimitive")}}
  - : Метод, преобразующий объект в примитив (примитивное значение).
- {{jsxref("Symbol.toStringTag")}}
  - : Строковое значение, используемое в качестве описания объекта по умолчанию. Используется функцией {{jsxref("Object.prototype.toString()")}}

## Методы

- {{jsxref("Symbol.for()", "Symbol.for(key)")}}
  - : Ищет существующие символы по заданному ключу и возвращает его, если он найден. В противном случае создаётся новый символ для данного ключа в глобальном реестре символов.
- {{jsxref("Symbol.keyFor", "Symbol.keyFor(sym)")}}
  - : Получает по разделяемому символу его ключ из глобального реестра символов.

## `Прототип Symbol`

Все символы наследуют от {{jsxref("Symbol.prototype")}}.

### Свойства

{{page('en-US/Web/JavaScript/Reference/Global_Objects/Symbol/prototype','Properties')}}

### Методы

{{page('en-US/Web/JavaScript/Reference/Global_Objects/Symbol/prototype','Methods')}}

## Примеры

### Использование оператора `typeof` с символами

Оператор {{jsxref("Operators/typeof", "typeof")}} позволяет идентифицировать символ.

```js
typeof Symbol() === "symbol";
typeof Symbol("foo") === "symbol";
typeof Symbol.iterator === "symbol";
```

### Преобразование типов с символами

Следующее необходимо помнить при преобразовании типа символов.

- При попытке конвертировать символ в число, будет брошено исключение {{jsxref("TypeError")}} (напр., `+sym` или `sym | 0`).
- Результатом нестрогого сравнения, `Object(sym) == sym`, будет `true`.
- `Symbol("foo") + "bar"` бросает исключение {{jsxref("TypeError")}} (невозможно преобразовать символ в строку). Это удерживает разработчика от, к примеру, случайного создания строгого поля у объекта из символа.
- Более ["безопасный" вызов `String(sym)`](/ru/docs/Web/JavaScript/Reference/Global_Objects/String#String_conversion) работает с символами как вызов {{jsxref("Symbol.prototype.toString()")}}. Заметьте, что в то же время `new String(sym)` бросит исключение.

### Символы и конструкция `for...in`

Символы не перечисляются при итерации {{jsxref("Statements/for...in","for...in")}}. В дополнение к этому, {{jsxref("Object.getOwnPropertyNames()")}} не вернёт символьные свойства объекта. Тем не менее, их можно получить с помощью {{jsxref("Object.getOwnPropertySymbols()")}}.

```js
var obj = {};

obj[Symbol("a")] = "a";
obj[Symbol.for("b")] = "b";
obj["c"] = "c";
obj.d = "d";

for (var i in obj) {
  console.log(i); // выведет "c" и "d"
}
```

### Символы и `JSON.stringify()`

JSON.stringify() игнорирует свойства с ключами `Symbol`:

```js
JSON.stringify({ [Symbol("foo")]: "foo" });
// '{}'
```

Подробности см. {{jsxref("JSON.stringify()")}}.

### Объекты-обёртки для символов в качестве ключей свойств

Когда объект-обёртка символа используется в качестве ключа свойства, этот объект приводится к символу, который он оборачивает:

```js
const sym = Symbol("foo");
const obj = { [sym]: 1 };
obj[sym]; // 1
obj[Object(sym)]; // тоже 1
```

## Спецификации

{{Specifications}}

## Совместимость с браузерами

{{Compat}}

## Смотрите также

- [Полифил `Symbol` в `core-js`](https://github.com/zloirock/core-js#ecmascript-symbol)
- {{jsxref("Operators/typeof", "typeof")}}
- [Типы и структуры данных JavaScript](/ru/docs/Web/JavaScript/Data_structures)
- [ES6 In Depth: Symbols](https://hacks.mozilla.org/2015/06/es6-in-depth-symbols/) на hacks.mozilla.org (2015)
