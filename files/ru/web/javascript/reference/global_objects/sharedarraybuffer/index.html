---
title: SharedArrayBuffer
slug: Web/JavaScript/Reference/Global_Objects/SharedArrayBuffer
translation_of: Web/JavaScript/Reference/Global_Objects/SharedArrayBuffer
tags:
  - Класс
  - JavaScript
  - Разделяемая память
  - SharedArrayBuffer
  - TypedArrays
---
<div>{{JSRef}}</div>

<p>Объект <strong><code>SharedArrayBuffer</code></strong> используется для создания разделённого буфера фиксированной длины для хранения примитивных бинарных данных, подобно объекту {{jsxref("ArrayBuffer")}}, но может быть использован для создания обзора на разделённую память. В отличие от <code>ArrayBuffer</code>, <code>SharedArrayBuffer</code> не может быть отсоединён.</p>

<h2 id="Описание">Описание</h2>

<h3 id="Распределение_и_разделение_памяти">Распределение и разделение памяти</h3>

<p>Для разделения памяти с помощью объекта {{jsxref("SharedArrayBuffer")}} между одним агентом в кластере и другим (агент может быть как основной программой страницы сайта, так и одним из веб-воркеров) используются <code><a href="/ru/docs/Web/API/Worker/postMessage">postMessage</a></code> и <a href="/ru/docs/Web/API/Web_Workers_API/Structured_clone_algorithm">алгоритм структурированного клонирования</a>.</p>

<p>Алгоритм структурированного клонирования принимает <code>SharedArrayBuffers</code> и <code>TypedArrays</code>, отображённый в <code>SharedArrayBuffers</code>. В обоих случаях объект <code>SharedArrayBuffer</code> передаётся получателю, что приводит к появлению нового приватного объекта SharedArrayBuffer внутри агента-получателя (так же как для {{jsxref("ArrayBuffer")}}). Оба объекта <code>SharedArrayBuffer</code> ссылаются на один и тот же блок общих данных, и сторонние эффекты в блоке в одном из агентов в итоге станут заметны и в другом.</p>

<pre class="brush: js">var sab = new SharedArrayBuffer(1024);
worker.postMessage(sab);
</pre>

<h3 id="Обновление_и_синхронизация_разделённой_памяти_с_помощью_атомарных_операций">Обновление и синхронизация разделённой памяти с помощью атомарных операций</h3>

<p>Разделённую память можно создавать и изменять одновременно в воркерах или основном потоке. В зависимости от системы (ЦПУ, ОС, браузера), распространение изменений по всем контекстам может занять некоторое время. Для синхронизации необходимы {{jsxref("Атомарные", "атомарные", "", 1)}} операции .</p>

<h3 id="API_принимающие_объекты_SharedArrayBuffer">API, принимающие объекты <code>SharedArrayBuffer</code></h3>

<ul>
 <li><a href="/en-US/docs/Web/API/WebGLRenderingContext/bufferData" title="Метод WebGLRenderingContext.bufferData() WebGL API инициализирует и создает хранилище данных буферного объекта."><code>WebGLRenderingContext.bufferData()</code></a></li>
 <li><a href="/en-US/docs/Web/API/WebGLRenderingContext/bufferSubData" title="Метод WebGLRenderingContext.bufferSubData() WebGL API обновляет подмножество хранилища данных буферного объекта."><code>WebGLRenderingContext.bufferSubData()</code></a></li>
 <li><a href="/en-US/docs/Web/API/WebGL2RenderingContext/getBufferSubData" title="Метод WebGL2RenderingContext.getBufferSubData() WebGL 2 API считывает данные из привязанной точки буфера и записывает их в ArrayBuffer или SharedArrayBuffer."><code>WebGL2RenderingContext.getBufferSubData()</code></a></li>
</ul>

<h3 id="Требования_безопасности">Требования безопасности</h3>

<p>Разделённая память и таймеры высокого разрешения были <a href="https://blog.mozilla.org/security/2018/01/03/mitigations-landing-new-class-timing-attack/">отключены в начале 2018 года</a> в связи с <a href="https://ru.wikipedia.org/wiki/Spectre_(%D1%83%D1%8F%D0%B7%D0%B2%D0%B8%D0%BC%D0%BE%D1%81%D1%82%D1%8C)">Spectre</a>. В 2020 году был стандартизирован новый, безопасный подход, чтобы включить разделённую память обратно. С некоторыми мерами безопасности <code><a href="/ru/docs/Web/API/Window/postMessage">postMessage()</a> больше не вызывает объекты <code>SharedArrayBuffer</code>, и разделённая память в различных потоках будет доступна.</p>

<p><a href="/en-US/docs/Web/Security/Secure_Contexts">Безопасный контекст</a> вашего документа — это основополагающее требование.</p>

<p>Для документов верхнего уровня необходимо включить два заголовка, чтобы изолировать ваш сайт от перекрёстных источников:</p>

<ul>
 <li><a href="/en-US/docs/Web/HTTP/Headers/Cross-Origin-Opener-Policy"><code>Cross-Origin-Opener-Policy</code></a> со значением <code>same-origin</code> (защищает ваш источник от атаки)</li>
 <li><a href="/en-US/docs/Web/HTTP/Headers/Cross-Origin-Embedder-Policy"><code>Cross-Origin-Embedder-Policy</code></a> со значением <code>require-corp</code> (защищает жертв от вашего источника)</li>
</ul>

<pre class="brush: plain">Cross-Origin-Opener-Policy: same-origin
Cross-Origin-Embedder-Policy: require-corp
</pre>

<p>Чтобы проверить, что изоляция от перекрёстных источников прошла успешно, протестируйте свойство <code><a href="/en-US/docs/Web/API/WindowOrWorkerGlobalScope/crossOriginIsolated">crossOriginIsolated</a></code>, доступное для контекстов окна и воркера:</p>

<pre class="brush: js">if (crossOriginIsolated) {
  // Выведи SharedArrayBuffer
} else {
  // Сделай что-то другое
}</pre>

<p>Ознакомьтесь с <a href="/en-US/docs/Web/JavaScript/Reference/Global_Objects/SharedArrayBuffer/Planned_changes">планируемыми изменениями разделённой памяти</a>, которые начинают внедряться в браузерах (в Firefox 79, например).</p>

<h3 id="Конструкции_требуют_оператор_new">Конструкции требуют оператор <code>new</code></h3>

<p>Конструкторы <code>SharedArrayBuffer</code> необходимо вызывать с помощью оператора {{jsxref("Operators/new", "new")}}. Вызов конструктора <code>SharedArrayBuffer</code> как функции без указания <code>new</code> вызовет ошибку {{jsxref("TypeError")}}.</p>

<pre class="brush: js example-bad">var sab = SharedArrayBuffer(1024);
// TypeError: вызов встроенного конструктора SharedArrayBuffer
// без new запрещено</pre>

<pre class="brush: js example-good">var sab = new SharedArrayBuffer(1024);</pre>

<h2 id="Конструктор">Конструктор</h2>

<dl>
 <dt><a href="/en-US/docs/Web/JavaScript/Reference/Global_Objects/SharedArrayBuffer/SharedArrayBuffer"><code>SharedArrayBuffer()</code></a></dt>
 <dd>Создаёт новый объект <code>SharedArrayBuffer</code>.</dd>
</dl>

<h3 id="Параметры">Параметры</h3>

<dl>
 <dt><code>length</code></dt>
 <dd>Размер для создания буферного массива, в байтах. Задаётся при создании массива и не может быть изменён. <strong>Только для чтения.</strong></dd>
</dl>

<h2 id="Методы">Методы</h2>

<dl>
 <dt>{{jsxref("SharedArrayBuffer.slice", "SharedArrayBuffer.prototype.slice(begin, end)")}}</dt>
 <dd>Возвращает новый <code>SharedArrayBuffer</code>, чьё содержимое — копия байтов изначального <code>SharedArrayBuffer</code> с <code>начала</code>, включительно, до <code>конца</code>, не включая его. Если <code>начало</code> или <code>конец</code> отрицательны, метод обращается к индексу массива, начиная с конца, а не с начала.</dd>
</dl>

<h2 id="Примеры">Примеры</h2>

<h3 id="Создание_нового_SharedArrayBuffer">Создание нового SharedArrayBuffer</h3>

<pre class="brush: js">var sab = new SharedArrayBuffer(1024);</pre>

<h3 id="Разделение_SharedArrayBuffer">Разделение SharedArrayBuffer</h3>

<pre class="brush: js">sab.slice();    // SharedArrayBuffer { byteLength: 1024 }
sab.slice(2);   // SharedArrayBuffer { byteLength: 1022 }
sab.slice(-2);  // SharedArrayBuffer { byteLength: 2 }
sab.slice(0, 1); // SharedArrayBuffer { byteLength: 1 }</pre>

<h3 id="Использование_в_буфере_WebGL">Использование в буфере WebGL</h3>

<pre class="brush: js">const canvas = document.querySelector('canvas');
const gl = canvas.getContext('webgl');
const buffer = gl.createBuffer();
gl.bindBuffer(gl.ARRAY_BUFFER, buffer);
gl.bufferData(gl.ARRAY_BUFFER, sab, gl.STATIC_DRAW);</pre>

<h2 id="Спецификации">Спецификации</h2>

<table class="standard-table">
 <tbody>
  <tr>
   <th scope="col">Спецификация</th>
  </tr>
  <tr>
   <td>{{SpecName('ESDraft', '#sec-sharedarraybuffer-objects', 'SharedArrayBuffer')}}</td>
  </tr>
 </tbody>
</table>

<h2 id="Поддержка_браузерами">Поддержка браузерами</h2>

<p>{{Compat("javascript.builtins.SharedArrayBuffer")}}</p>

<h2 id="Смотрите_также">Смотрите также</h2>

<ul>
 <li>{{jsxref("Atomics")}}</li>
 <li>{{jsxref("ArrayBuffer")}}</li>
 <li><a href="/ru/docs/Web/JavaScript/Typed_arrays">Типизированные массивы JavaScript</a></li>
 <li><a href="/ru/docs/Web/API/Web_Workers_API">Веб-воркеры</a></li>
 <li><a href="https://github.com/lars-t-hansen/parlib-simple">parlib-simple</a> — простая библиотека, предоставляющая синхронизацию и абстракции распределения работы.</li>
 <li><a href="https://github.com/tc39/ecmascript_sharedmem/blob/master/TUTORIAL.md">Разделённая память — краткий туториал</a></li>
 <li>
  <p><a href="https://hacks.mozilla.org/2016/05/a-taste-of-javascripts-new-parallel-primitives/">Немного о новых параллельных примитивах JavaScript – Mozilla Hacks</a></p>
 </li>
</ul>
