---
title: Прототипы объектов
slug: Learn/JavaScript/Objects/Object_prototypes
tags:
  - JavaScript
  - create()
  - Конструктор
  - Начинающий
  - ООП
  - Обучение
  - Объект
  - Статья
  - прототип
translation_of: Learn/JavaScript/Objects/Object_prototypes
original_slug: Learn/JavaScript/Объекты/Object_prototypes
---

{{LearnSidebar}}{{PreviousMenuNext("Learn/JavaScript/Objects/Object-oriented_JS", "Learn/JavaScript/Objects/Inheritance", "Learn/JavaScript/Objects")}}Прототипы - это механизм, с помощью которого объекты JavaScript наследуют свойства друг от друга. В этой статье мы объясним, как работают цепочки прототипов, и рассмотрим, как свойство prototype можно использовать для добавления методов к существующим конструкторам.

<table>
  <tbody>
    <tr>
      <th scope="row">Необходимые знания:</th>
      <td>
        Знакомство с основами JavaScript
        (смотри
        <a href="/ru-RU/docs/Learn/JavaScript/First_steps">Первые шаги</a> и
        <a href="/ru-RU/docs/Learn/JavaScript/Building_blocks"
          >Строительные блоки</a
        >) и
        <a href="/ru-RU/docs/Learn/JavaScript/Objects/Basics"
          >Введение в объекты</a
        >.
      </td>
    </tr>
    <tr>
      <th scope="row">Цель:</th>
      <td>
        Чтобы понять прототипы объектов JavaScript, как работают цепочки прототипов,
и как установить прототип объекта.
      </td>
    </tr>
  </tbody>
</table>

## Цепочка прототипов

В консоли браузера попробуйте создать объектный литерал:

```js
const myObject = {
  city: "Москва",
  greet() {
    console.log(`Привет из ${this.city}`);
  },
};

myObject.greet(); // Привет из Москва
```

Это объект с одним свойством `city`, и одним методом `greet()`. Если вы введете в консоль имя объекта, за которым следует точка, например `MyObject.`, то в консоли появится список всех свойств, доступных этому объекту. Вы увидите, что наряду с `городом` и `приветствием` есть множество других свойств!

```
__defineGetter__
__defineSetter__
__lookupGetter__
__lookupSetter__
__proto__
city
constructor
greet
hasOwnProperty
isPrototypeOf
propertyIsEnumerable
toLocaleString
toString
valueOf
```

Попробуйте получить доступ к одному из них:

```js
myObject.toString(); // "[object Object]"
```

Это работает (даже если не очевидно, что делает `toString()`).

Что это за дополнительные свойства и откуда они берутся?

Каждый объект в JavaScript имеет встроенное свойство, которое называется его **прототипом**. Прототип сам по себе является объектом, поэтому у прототипа будет свой собственный прототип, образующий так называемую **цепочку прототипов**. Цепочка заканчивается, когда мы достигаем прототипа, который равен `null` для своего собственного прототипа.

> **Примечание:** Свойство объекта, указывающее на его прототип, **не** называется `prototype`. Его название не является стандартным, но на практике все браузеры используют [`__proto__`](/ru-RU/docs/Web/JavaScript/Reference/Global_Objects/Object/proto). Стандартным способом доступа к прототипу объекта является метод {{jsxref("Object/getPrototypeOf", "Object.getPrototypeOf()")}}.

Когда вы пытаетесь получить доступ к свойству объекта: если свойство не может быть найдено в самом объекте, выполняется поиск свойства в прототипе. Если свойство по-прежнему не может быть найдено, то выполняется поиск в прототипе прототипа и так далее (по цепочке), пока либо свойство не будет найдено, либо не будет достигнут конец цепочки, и в этом случае возвращается `undefined`.

Поэтому, когда мы вызываем `MyObject.toString()`, браузер делает это:

- ищет `toString` в `MyObject`
- не может найти его там, поэтому ищет в прототипе объекта `MyObject` `toString`
- находит его там и вызывает его.

Что является прототипом для `MyObject`? Чтобы выяснить это, мы можем использовать функцию `Object.getPrototypeOf()`:

```js
Object.getPrototypeOf(myObject); // Object { }
```

Это объект под названием `Object.prototype`, и есть самый базовый прототип, который есть у всех объектов по умолчанию. Прототип `Object.prototype` равен `null`, поэтому он находится в конце цепочки прототипов:

![Цепочка прототипов для myObject](myobject-prototype-chain.svg)

Прототипом объекта не всегда является `Object.prototype`. Попробуй это:

```js
const myDate = new Date();
let object = myDate;

do {
  object = Object.getPrototypeOf(object);
  console.log(object);
} while (object);

// Date.prototype
// Object { }
// null
```

Этот код создает объект `Date`, затем проходит по цепочке прототипов, регистрируя прототипы. Это показывает нам, что прототипом `myDate` является объект `Date.prototype`, а прототипом _that_ является `Object.prototype`.

![Цепочка прототипов для myDate](mydate-prototype-chain.svg)

In fact, when you call familiar methods, like `myDate2.getMonth()`,
you are calling a method that's defined on `Date.prototype`.

## Shadowing properties

Что произойдет, если вы определите свойство в объекте, когда свойство с тем же именем определено в прототипе объекта? Давайте посмотрим:

```js
const myDate = new Date(1995, 11, 17);

console.log(myDate.getYear()); // 95

myDate.getYear = function () {
  console.log("что-то другое");
};

myDate.getYear(); // 'что-то другое'
```

Это должно быть предсказуемо, учитывая описание цепочки прототипов. Когда мы вызываем `getYear()`, браузер сначала ищет в `myDate` свойство с таким именем и проверяет прототип только в том случае, если `myDate` его не определяет. Итак, когда мы добавляем `getYear()` в `myDate`, вызывается тот метод, который в `myDate`.

Это называется "затенением" свойства.

## Создание прототипа

Существуют различные способы создания прототипа объекта в JavaScript, и здесь мы опишем два из них: `Object.create()` и конструкторы.

### С помощью Object.create

Метод `Object.create()` создает новый объект и позволяет указать объект, который будет использоваться в качестве прототипа нового объекта.

Вот пример:

```js
const personPrototype = {
  greet() {
    console.log("привет!");
  },
};

const carl = Object.create(personPrototype);
carl.greet(); // привет!
```

Здесь мы создаем объект `personPrototype`, у которого есть метод `great()`. Затем мы используем `Object.create()` для создания нового объекта с `personPrototype` в качестве прототипа. Теперь мы можем вызвать `great()` для нового объекта, и прототип обеспечивает его реализацию.

### С помощью constructor

В JavaScript все функции имеют свойство с именем `prototype`. Когда вы вызываете функцию в качестве конструктора, это свойство устанавливается в качестве прототипа вновь созданного объекта (по соглашению, в свойстве с именем `__proto__`).

Таким образом, если мы установим `прототип` конструктора, мы можем гарантировать, что всем объектам, созданным с помощью этого конструктора, будет присвоен этот прототип:

```js
const personPrototype = {
  greet() {
    console.log(`Привет, моё имя ${this.name}!`);
  },
};

function Person(name) {
  this.name = name;
}

Object.assign(Person.prototype, personPrototype);
// или
// Person.prototype.greet = personPrototype.greet;
```

Здесь мы создаём:

- объект `personPrototype`, у которого есть метод `great()'
- функция-конструктор `Person()`, которая инициализирует имя создаваемого пользователя.

Затем мы помещаем методы, определенные в `personPrototype`, в свойство `prototype` функции `Person`, используя [Object.assign](/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/assign).

После этого объекты, созданные с помощью `Person()`, получат `Person.prototype` в качестве своего прототипа, который автоматически содержит метод `greet`.

```js
const reuben = new Person("Reuben");
reuben.greet(); // Привет, моё имя Reuben!
```

Это также объясняет, почему мы ранее говорили, что прототип `myDate` называется `Date.prototype`: это свойство `prototype` конструктора `Date`.

### Собственные свойства

Объекты, которые мы создаем с помощью приведенного выше конструктора `Person`, имеют два свойства:

- свойство `name`, которое задается в конструкторе, поэтому оно отображается непосредственно на объектах `Person`
- метод `great()`, который задан в прототипе.

Часто можно увидеть этот шаблон, в котором методы определены в прототипе, но свойства данных определены в конструкторе. Это потому, что методы обычно одинаковы для каждого объекта, который мы создаем, в то время как мы часто хотим, чтобы каждый объект имел свое собственное значение для своих свойств данных (точно так же, как здесь, где у каждого человека разное имя).

Свойства, которые определены непосредственно в объекте, например `name` здесь, называются **собственными свойствами**, и вы можете проверить, является ли свойство собственным свойством, используя статический {{jsxref("Object/hasOwn", "Object.hasOwn()")}} метод:

```js
const irma = new Person("Ирма");

console.log(Object.hasOwn(irma, "name")); // true
console.log(Object.hasOwn(irma, "greet")); // false
```

> **Note:** Вы также можете использовать здесь нестатический метод {{jsxref("Object/hasOwnProperty", "Object.hasOwnProperty()")}}, но мы рекомендуем вам использовать `Object.hasOwn()`.

## Прототипы и наследование

Прототипы - это мощная и очень гибкая функция JavaScript, позволяющая повторно использовать код и комбинировать объекты.

В частности, они поддерживают версию **наследования **. Наследование - это особенность объектно-ориентированных языков программирования, которая позволяет программистам выразить идею о том, что некоторые объекты в системе являются более специализированными версиями других объектов.

Например, если мы моделируем школу, у нас могут быть _professors_ и _students_: они оба _people_, поэтому имеют некоторые общие черты (например, у них обоих есть имена), но каждый может добавлять дополнительные функции (например, у профессоров есть предмет, который они преподают), или может реализовать одна и та же функция по-разному. В системе ООП мы могли бы сказать, что и профессора, и студенты ** наследуют от ** людей.

Вы можете видеть, как в JavaScript, если объекты `Professor` и `Student` могут иметь прототипы `Person`, то они могут наследовать общие свойства, добавляя и переопределяя те свойства, которые должны отличаться.

В следующей статье мы обсудим наследование наряду с другими основными функциями объектно-ориентированных языков программирования и посмотрим, как JavaScript их поддерживает.

## Заключение

В этой статье мы рассмотрели прототипы объектов JavaScript, в том числе то, как цепочки объектов прототипов позволяют объектам наследовать функции друг от друга, свойство `prototype` и как его можно использовать для добавления методов в конструкторы, а также другие связанные темы.

В следующей статье мы рассмотрим концепции, лежащие в основе объектно-ориентированного программирования.

{{PreviousMenuNext("Learn/JavaScript/Objects/Object-oriented_JS", "Learn/JavaScript/Objects/Inheritance", "Learn/JavaScript/Objects")}}

## В этом модуле

- [Основы объекта](/ru/docs/Learn/JavaScript/Объекты/Основы)
- [Объектно-ориентированный JavaScript для начинающих](/ru/docs/Learn/JavaScript/Объекты/Object-oriented_JS)
- [Прототипы объектов](/ru/docs/Learn/JavaScript/Объекты/Object_prototypes)
- [Наследование в JavaScript](/ru/docs/Learn/JavaScript/Объекты/Inheritance)
- [Работа с данными JSON](/ru/docs/Learn/JavaScript/Объекты/JSON)
- [Практика построения объектов](/ru/docs/Learn/JavaScript/Объекты/Object_building_practice)
- [Добавление функций в нашу демонстрацию прыгающих шаров](/ru/docs/Learn/JavaScript/Объекты/Adding_bouncing_balls_features)
