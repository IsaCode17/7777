---
title: Отзывчивый дизайн
slug: Learn/CSS/CSS_layout/Responsive_Design
---

{{learnsidebar}}{{PreviousMenuNext("Learn/CSS/CSS_layout/Multiple-column_Layout", "Learn/CSS/CSS_layout/Media_queries", "Learn/CSS/CSS_layout")}}

На заре веб-дизайна страницы создавались для экрана определённого размера. Если у пользователя был экран большего или меньшего размера чем ожидал дизайнер, то результат мог быть от нежелательных полос прокрутки, до слишком длинной строки и плохого использования пространства. Поскольку становились доступны много различных размеров экранов, появилась концепция _отзывчивого (адаптивного) веб-дизайна_ _(responsive web design_ (RWD)) — набор методов, которые позволяют веб-страницам менять свой макет и внешний вид в соответствии с разной шириной экрана, разрешением и т.д. Это та самая, идея которая изменила подход к дизайну веба для множества устройств, и в этой статье мы поможем вам понять основные методы, которые вам необходимо знать, чтобы освоить его.

| Необходимые знания: | Основы HTML (изучите [Введение в HTML](/ru/docs/Learn/HTML/Introduction_to_HTML)), идея о том как работает CSS (изучите [Введение в CSS](/ru/docs/Learn/CSS/Introduction_to_CSS) и [Устройство CSS](/ru/docs/Learn/CSS/Building_blocks).) |
| ------------------- | ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| Задача:             | Понять базовые концепции и историю отзывчивого дизайна.                                                                                                                                                                                   |

## Исторические макеты сайтов

В какой-то момент истории при разработке веб-сайта у вас было два варианта:

- Вы могли создать _жидкий_ сайт, который будет растягиваться чтобы заполнить окно браузера
- или сайт с _фиксированной шириной_, который будет иметь фиксированный размер в пикселях.

Эти два подхода, как правило, приводили к тому, что веб-сайт лучше всего выглядел на экране человека, создавшего сайт! Жидкий сайт приводил к раздавленному дизайну на маленьких экранах (как видно ниже) и не читаемо длинным строкам на больших.

![A layout with two columns squashed into a mobile size viewport.](mdn-rwd-liquid.png)

> [!NOTE]
> Посмотрите этот простой жидкий макет: [пример](https://mdn.github.io/css-examples/learn/rwd/liquid-width.html), [исходный код](https://github.com/mdn/css-examples/blob/master/learn/rwd/liquid-width.html). При просмотре примера, растягивайте и сжимайте окно браузера чтобы увидеть, как это выглядит при разных размерах.

Сайт с фиксированной шириной рисковал иметь горизонтальную полосу прокрутки на экранах меньших чем ширина сайта (как видно ниже) и много белого пространства на краях дизайна на больших экранах.

![A layout with a horizontal scrollbar in a mobile viewport.](mdn-rwd-fixed.png)

> [!NOTE]
> Посмотрите этот простой макет с фиксированной шириной: [пример](https://mdn.github.io/css-examples/learn/rwd/fixed-width.html), [исходный код](https://github.com/mdn/css-examples/blob/master/learn/rwd/fixed-width.html). Снова изучите результат по мере изменения размера окна браузера.

> [!NOTE]
> Скриншоты выше сделаны используя [Responsive Design Mode](/ru/docs/Tools/Responsive_Design_Mode) в Firefox DevTools.

Когда мобильный веб стал становиться реальностью с первыми функциональными телефонами, компании желающие охватить мобильники начали создавать в основном специальные мобильные версии своих сайтов, с различными URL (часто что-то наподобие _m.example.com_ или _example.mobi_). Это означало, что необходимо было разрабатывать и поддерживать в актуальном состоянии две отдельные версии сайта.

Кроме того, эти мобильные сайты часто предлагали очень урезанный вариант. Поскольку мобильные гаджеты стали мощнее и способными отображать целые веб-сайты, пользователей мобильных устройств раздражало, что они обнаруживали себя запертыми в мобильной версии сайта, неспособные получить доступ к информации, которая, как они знали, есть в полнофункциональной версии сайта.

## Гибкий макет до отзывчивого дизайна

Было разработано несколько подходов чтобы попытаться разрешить недостатки построения веб-сайтов жидким методом или методом с фиксированной шириной. В 2004 году Камерон Адамс написал пост [Resolution dependent layout](http://www.themaninblue.com/writing/perspective/2004/09/21/), описывающий метод создания дизайна который мог бы адаптироваться к разным разрешениям экрана. Этот подход требовал, чтобы JavaScript узнавал разрешение экрана и загружал корректный CSS.

Зои Миккели Гилленвотер сыграла важную роль в свой работе описав и формализовав различные способы посредствам которых могут быть созданы гибкие сайты, пытаясь найти золотую середину между заполнением экрана или полностью фиксированным размером.

## Отзывчивый дизайн

Термин адаптивный дизайн был [Придуман Итаном Маркоттом в 2010 году](https://alistapart.com/article/responsive-web-design/) и описывал использование трёх методов в сочетании.

1. Первой была идея жидких сеток, нечто что уже исследовала Гилленвотер, что можно прочитать в статье Маркотта - [Fluid Grids](https://alistapart.com/article/fluidgrids/) (опубликовано в 2009 в A List Apart).
2. Вторым методом была идея [жидких изображений](http://unstoppablerobotninja.com/entry/fluid-images). Используя очень простой метод настройки свойства `max-width` на `100%`, изображения будут становиться меньше если содержащий столбец становится уже чем изначальный размер изображения, но никогда не становится больше. Это позволяет изображению уменьшаться чтобы соответствовать столбцу гибких размеров, а не перекрываться с ним, но не расти и становиться пиксельным если столбец становится шире изображения.
3. Третьим ключевым компонентом были [медиавыражения](/ru/docs/Web/CSS/Media_Queries). Медиавыражения позволяют переключать тип макета применяя только CSS то, что Камерон Адамс исследовал, используя JavaScript. Вместо того чтобы иметь один макет для всех размеров экранов, макет мог изменяться. Боковые панели можно перемещать для маленьких экранов, либо отображать альтернативную навигацию.

Очень важно понять, что **адаптивный веб-дизайн** — **это не отдельная технология**, это термин используемый, чтобы описать подход к веб-дизайну или набор лучших практик, используемых для создания макета, который может реагировать на используемое устройство для просмотра контента. В первоначальном исследовании Маркотта это означало гибкие сетки (с использованием floats) и медиавыражения, однако почти за 10 лет, прошедших с момента написания этой статьи, адаптивная работа стала стандартом по умолчанию. Современные методы макета CSS отзывчивы по своей сути, и у нас есть новые штучки, встроенные в веб-платформу для того, чтобы делать дизайн отзывчивых сайтов проще.

Остальная часть этой статьи укажет вам на различные функции веб-платформы, которые вы, возможно, захотите использовать при создании адаптивного сайта.

## Медиавыражения

Отзывчивый дизайн появился благодаря медиавыражениям (media queries). Спецификация Media Queries Level 3 стала Рекомендованным Кандидатом в 2009 году, что означает, что она была признана готовой к реализации в браузерах. Медиавыражения позволяют нам проводить серию тестов (например, является ли экран пользователя больше, чем определённая ширина или разрешение) и выборочно применять CSS к стилю страницы соответственно с нуждами пользователя.

Например, следующее медиавыражение проверяет отображается ли текущая страница как экранная медиа (а не как печатный документ) и имеет ли область просмотра ширину как минимум 800 px. CSS будет применяться к селектору `.container` только если эти две вещи истины.

```css
@media screen and (min-width: 800px) {
  .container {
    margin: 1em 2em;
  }
}
```

Вы можете добавлять несколько медиавыражений в пределах одной таблицы стилей, подстраивая весь ваш макет или его части так, чтобы наилучшим образом соответствовать разным размерам экрана. Точки, в которых применяются медиавыражения и меняется макет, известны как _контрольные точки._

Общим подходом при использовании медиавыражений является создание простого одноколоночного макета для устройств с узкими экранами (например, мобильные телефоны), затем проверка для больших экранов и применение макета с несколькими столбцам, когда вы знаете, что у вас достаточно ширины экрана, чтобы уместить все. Такой подход часто называют **mobile first** дизайном.

Узнать больше о [медиавыражениях](/ru/docs/Web/CSS/Media_Queries) можно в документации MDN.

## Гибкие сетки

Отзывчивые сайты не просто меняют свой макет между контрольными точками, они построены на гибких сетках. Гибкая сетка подразумевает что вам не надо заботиться о каждом возможном существующем размере устройства и строить для них идеальный макет в пикселях. Такой подход был бы невозможен имея широкое множество существующих устройств разных размеров, как и факт того, что даже на ПК люди не всегда используют браузер с развёрнутым до максимума окном.

Используя гибкую сетку, вам всего лишь надо добавить контрольную точку и изменить дизайн в точке, когда ваш контент начинает выглядеть плохо. Например, если длина строки становится нечитаемо длинной при увеличении размера экрана, или блок становится сдавленным с двумя словами в каждой строке при сужении экрана.

В первые дни отзывчивого дизайна, нашим единственным вариантом выполнения было использование [floats](/ru/docs/Learn/CSS/CSS_layout/Floats). Гибкий обтекаемый макет достигался путём присвоения каждому элементу процентной ширины удостоверившись, что итоговые значения в макете не превышают 100%. В своей оригинальной статье о плавучих сетках Маркотт подробно описал формулу для преобразования макета, созданного с использованием пикселей, в проценты.

```
target / context = result
```

Например, если размер нашего целевого столбца — 60 пикселей, а контекст (или контейнер) в котором он находится — 960 пикселей, то мы делим 60 на 960 чтобы получить значение которое мы можем использовать в нашем CSS, после переноса десятичной точки вправо на 2 цифры.

```css
.col {
  width: 6.25%; /* 60 / 960 = 0.0625 */
}
```

Этот подход сегодня можно найти во многих местах в Интернете и он задокументирован здесь в разделе макетов в нашей статье [Устаревших методов макетов](/ru/docs/Learn/CSS/CSS_layout/Legacy_Layout_Methods). В вашей работе вероятно, что вы столкнётесь с веб-сайтами, использующими этот подход, поэтому стоит понимать его, даже если вы не будете строить современные сайты используя гибкие сетки основанные на float.

Следующий пример демонстрирует простой отзывчивый дизайн, с использованием медиавыражений и гибких сеток. На узких экранах макет отображает блоки, расположенные друг над другом:

![A mobile view of the layout with boxes stacked on top of each other vertically.](mdn-rwd-mobile.png)

На более широких экранах они перемещаются в два столбца:

![A desktop view of a layout with two columns.](mdn-rwd-desktop.png)

> [!NOTE]
> Вы можете найти [живой пример](https://mdn.github.io/css-examples/learn/rwd/float-based-rwd.html) и [исходный код](https://github.com/mdn/css-examples/blob/master/learn/rwd/float-based-rwd.html) этого примера на GitHub.

## Современные технологии макетов

Современные методы макетов такие как [Макет с несколькими столбцами](/ru/docs/Learn/CSS/CSS_layout/Multiple-column_Layout), [Flexbox](/ru/docs/Learn/CSS/CSS_layout/Flexbox), и [Grid](/ru/docs/Learn/CSS/CSS_layout/Grids) являются отзывчивыми по умолчанию. Они все предполагают, что вы пытаетесь создать гибкую сетку и дают вам более лёгкий способ сделать так.

### Multicol

Самый старый из этих методов — это multicol, когда вы задаёте `column-count`, это отражает то на сколько столбцов вы хотите разбить ваш контент. Далее браузер рассчитывает их размер, размер, который изменится согласно размеру экрана.

```css
.container {
  column-count: 3;
}
```

Если вместо этого вы зададите `column-width`, то вы определите _минимальную_ ширину. Браузер создаст столько столбцов той ширины, сколько будет комфортно умещаться в контейнер, а затем поделит оставшееся пространство между всеми столбцами. Поэтому число столбцов будет меняться согласно тому сколько имеется места.

```css
.container {
  column-width: 10em;
}
```

### Flexbox

В Flexbox, в качестве исходного поведения, flex элементы будут сжиматься и распределять пространство между элементами в соответствии с пространством в их контейнере. Изменяя значения `flex-grow` и `flex-shrink` вы можете указать, как вы хотите, чтобы предметы вели себя когда они сталкиваются с большим или меньшим пространством вокруг себя.

В примере ниже каждый flex элемент будет принимать равное количество пространства во flex контейнере используя запись `flex: 1` как описано в главе [Flexbox: Гибкое изменение размеров flex элементов](/ru/docs/Learn/CSS/CSS_layout/Flexbox#Flexible_sizing_of_flex_items).

```css
.container {
  display: flex;
}

.item {
  flex: 1;
}
```

> [!NOTE]
> В качестве примера мы перестроили простой отзывчивый макет выше, в этот раз используя flexbox. Вы видите что нас больше не надо использовать странные процентные значения для подсчёта размера столбцов: [пример](https://mdn.github.io/css-examples/learn/rwd/flex-based-rwd.html), [исходный код](https://github.com/mdn/css-examples/blob/master/learn/rwd/flex-based-rwd.html).

### CSS grid

В макете CSS Grid единицы измерения `fr` позволяют распределять доступное пространство между дорожками сетки. Следующий пример создаёт grid контейнер с тремя дорожками размером `1fr`. Это создаст три вертикальные дорожки, каждая занимающая одну часть свободного пространства в контейнере. Вы можете узнать больше об этом подходе к созданию сетки в теме Изучение Макета Grid в разделе [Гибкие grids с единицами fr](/ru/docs/Learn/CSS/CSS_layout/Grids#Flexible_grids_with_the_fr_unit).

```css
.container {
  display: grid;
  grid-template-columns: 1fr 1fr 1fr;
}
```

> [!NOTE]
> Версия grid макета ещё проще, поскольку мы можем определить столбцы в .wrapper: [пример](https://mdn.github.io/css-examples/learn/rwd/grid-based-rwd.html), [исходный код](https://github.com/mdn/css-examples/blob/master/learn/rwd/grid-based-rwd.html).

## Отзывчивые изображения

Самый простой подход к отзывчивым изображениям был описан в ранних статьях Маркотта по отзывчивому дизайну. По сути, вы берёте изображение максимального размера, которое могло понадобиться, и уменьшаете его. Этот подход до сих пор используется и в большинстве таблиц стилей вы найдёте следующий CSS:

```css
img {
  max-width: 100%;
}
```

Существуют очевидные недостатки к этому подходу. Изображение может быть изображено намного меньше своего исходного размера, что является пустой тратой пропускной способности — пользователь мобильных может загружать изображение, в несколько раз превышающее размер того, что он фактически видит в окне браузера. Кроме того, вам может не понадобиться такое же соотношение сторон изображения на мобильном устройстве, как на компьютере. Либо, учитывая меньший размер изображения на мобильном телефоне, вы можете захотеть показать совсем другое изображение, которое легче понять на маленьком экране. Такие вещи можно достичь, просто уменьшая изображение.

Отзывчивые изображения, используя элемент {{htmlelement("picture")}} и атрибуты `srcset` и `sizes` элемента {{htmlelement("img")}} оба решают эти проблемы. Вы можете указать несколько размеров вместе с «подсказками» (метаданные, описывающие размер экрана и разрешение, для которых изображение лучше всего подходит), и браузер выберет наиболее подходящее изображение для каждого устройства, гарантируя, что пользователь загрузит изображение подходящего размера для устройства, которое они используют.

Вы также можете напрямую использовать изображения разных размеров, обеспечивая разное кадрирование или совершенно другое изображение для разных размеров экрана.

Вы можете найти подробное [руководство по отзывчивым изображениям в разделе изучения HTML](/ru/docs/Learn/HTML/Multimedia_and_embedding/Responsive_images) на MDN.

## Отзывчивая типографика

Элементом отзывчивого дизайна, не освещённого ранее в работе, была идея отзывчивой типографики. Главным образом, она описывает изменение размеров шрифта в зависимости от ширины экрана при помощи медиавыражений.

В этом примере, мы хотим задать нашему заголовку первого уровня `4rem`, что значит, что он будет в четыре раза больше нашего базового размера шрифта. Это очень большой заголовок! Мы хотим этот гигантский заголовок только на экранах больших размеров, поэтому мы сначала создаём меньший заголовок, а затем используем медиавыржаение, чтобы переписать его для больших экранов, если мы знаем, что у пользователя есть экран размером как минимум `1200px`.

```css
html {
  font-size: 1em;
}

h1 {
  font-size: 2rem;
}

@media (min-width: 1200px) {
  h1 {
    font-size: 4rem;
  }
}
```

Мы отредактировали наш приведённый выше пример отзывчивой сетки grid, чтобы он также включал в себя адаптивный тип, используя описанный метод. Вы можете видеть, как заголовок меняет размеры, когда макет переходит в версию с двумя столбцами.

В мобильных версиях заголовок меньше:

![A stacked layout with a small heading size.](mdn-rwd-font-mobile.png)

На компьютерах, однако, мы видим больший размер заголовка:

![A two column layout with a large heading.](mdn-rwd-font-desktop.png)

> [!NOTE]
> Смотрите этот пример в действии: [пример](https://mdn.github.io/css-examples/learn/rwd/type-rwd.html), [исходный код](https://github.com/mdn/css-examples/blob/master/learn/rwd/type-rwd.html).

Такой подход к типографике показывает, что вам не нужно ограничиваться в использовании медиавыражений только изменением макета страницы. Они могут быть использоваться для настройки любого элемента, чтобы сделать его более удобным или привлекательным при других размерах экрана.

### Использование единиц области просмотра для отзывчивой типографики

Интересным подходом является использование блока просмотра `vw` для обеспечения отзывчивой типографики. `1vw` равен одному проценту от ширины области просмотра, то есть если вы зададите размер шрифта с помощью `vw`, он всегда будет соответствовать размеру области просмотра.

```css
h1 {
  font-size: 6vw;
}
```

Проблема в том, что пользователь теряет возможность масштабировать любой текст, заданный с помощью единицы `vw`, поскольку этот текст всегда связан с размером области просмотра. **Поэтому никогда не следует задавать текст, используя только единицы области просмотра**.

Решение есть, и оно заключается в использовании [`calc()`](/ru/docs/Web/CSS/calc). Если вы добавите блок `vw` к значению, заданному с помощью фиксированного размера, например `em` или `rem`, то текст все равно будет масштабироваться. По сути, блок `vw` добавляется поверх этого масштабируемого значения:

```css
h1 {
  font-size: calc(1.5rem + 3vw);
}
```

Это означает, что нам нужно только один раз указать размер шрифта для заголовка, а не настраивать его для мобильных устройств и переопределять в медиазапросах. Шрифт постепенно увеличивается по мере увеличения размера области просмотра.

> [!NOTE] Посмотрите на пример этого в действии: [пример](https://mdn.github.io/css-examples/learn/rwd/type-vw.html), [исходный код](https://github.com/mdn/css-examples/blob/master/learn/rwd/type-vw.html).

## Мета-тег viewport

Если вы посмотрите на HTML-источник отзывчивой страницы, то обычно увидите следующий тег {{htmlelement("meta")}} в `<head>` документа.

```html
<meta name="viewport" content="width=device-width,initial-scale=1" />
```

Этот метатег сообщает мобильным браузерам, что они должны установить ширину области просмотра, соответствующую ширине устройства, и масштабировать документ до 100% от его предполагаемого размера, что позволит отобразить документ в оптимизированном для мобильных устройств размере, который вы задумали.

Почему это необходимо? Потому что мобильные браузеры склонны обманывать относительно ширины области просмотра.

Этот метатег существует потому, что когда появился iPhone и люди начали просматривать сайты на маленьком экране телефона, большинство сайтов не были оптимизированы для мобильных устройств. Поэтому мобильный браузер устанавливал ширину области просмотра в 960 пикселей, рендерил страницу с такой шириной и показывал результат в виде уменьшенной версии макета для настольных компьютеров. Другие мобильные браузеры (например, на Google Android) делали то же самое. Пользователи могли увеличивать и панорамировать веб-сайт, чтобы просмотреть интересующие их фрагменты, но выглядело это плохо. Такое можно наблюдать и сегодня, если вы имеете несчастье наткнуться на сайт, не имеющий отзывчивого дизайна.

Проблема в том, что ваш отзывчивый дизайн с точками разрыва и медиазапросами не будет работать так, как задумано, на мобильных браузерах. Если у вас узкоэкранный макет, который срабатывает при ширине области просмотра 480px или меньше, а область просмотра установлена на 960px, вы никогда не увидите свой узкоэкранный макет на мобильных устройствах. Задавая `width=device-width`, вы заменяете стандартное значение Apple `width=960px` на фактическую ширину устройства, поэтому ваши медиа-запросы будут работать так, как нужно.

**Так что вы должны _всегда_ включать приведенную выше строку HTML в шапку ваших документов.**.

Существуют и другие настройки, которые можно использовать в мета-теге viewport, однако в целом вам подойдет приведенная выше строка.

- `initial-scale`: Устанавливает начальный масштаб страницы, который мы задаем равным 1.
- `height`: Устанавливает определенную высоту для области просмотра.
- `minimum-scale`: Устанавливает минимальный уровень масштабирования.
- `maximum-scale`: Устанавливает максимальный уровень масштабирования.
- `user-scalable`: Предотвращает масштабирование, если установлено значение `no`.

Вам следует избегать использования `minimum-scale`, `maximum-scale` и, в особенности, установки `user-scalable` в `no`. Пользователи должны иметь возможность изменять масштаб так сильно или так мало, как им нужно; предотвращение этого приводит к проблемам с доступностью.

## Подытожим

Отзывчивый дизайн - это дизайн сайта или приложения, который реагирует на среду, в которой его просматривают. Он включает в себя ряд функций и техник CSS и HTML и теперь по сути является тем, как мы создаем сайты по умолчанию. Подумайте о сайтах, которые вы посещаете на своем телефоне - вероятно, довольно редко можно встретить сайт, который представляет собой уменьшенную версию для настольных компьютеров или где вам нужно прокручивать страницу вбок, чтобы найти что-то. Это происходит потому, что веб перешел на такой подход к разработке отзывчивого дизайна.

Кроме того, стало гораздо проще создавать отзывчивые дизайны с помощью методов верстки, которые вы изучили в этих уроках. Если вы новичок в веб-разработке, то сегодня в вашем распоряжении гораздо больше инструментов, чем в первые дни создания отзывчивого дизайна. Поэтому стоит проверить возраст всех материалов, на которые вы ссылаетесь. Хотя исторические статьи по-прежнему полезны, современное использование CSS и HTML значительно упрощает создание элегантных и полезных дизайнов, независимо от того, с какого устройства посетитель просматривает сайт.

{{PreviousMenuNext("Learn/CSS/CSS_layout/Multiple-column_Layout", "Learn/CSS/CSS_layout/Media_queries", "Learn/CSS/CSS_layout")}}

## In this module

- [Introduction to CSS layout](/ru/docs/Learn/CSS/CSS_layout/Introduction)
- [Normal flow](/ru/docs/Learn/CSS/CSS_layout/Normal_Flow)
- [Flexbox](/ru/docs/Learn/CSS/CSS_layout/Flexbox)
- [Grid](/ru/docs/Learn/CSS/CSS_layout/Grids)
- [Floats](/ru/docs/Learn/CSS/CSS_layout/Floats)
- [Positioning](/ru/docs/Learn/CSS/CSS_layout/Positioning)
- [Multiple-column layout](/ru/docs/Learn/CSS/CSS_layout/Multiple-column_Layout)
- [Responsive design](/ru/docs/Learn/CSS/CSS_layout/Responsive_Design)
- [Beginner's guide to media queries](/ru/docs/Learn/CSS/CSS_layout/Media_queries)
- [Legacy layout methods](/ru/docs/Learn/CSS/CSS_layout/Legacy_Layout_Methods)
- [Supporting older browsers](/ru/docs/Learn/CSS/CSS_layout/Supporting_Older_Browsers)
- [Fundamental layout comprehension assessment](/ru/docs/Learn/CSS/CSS_layout/Fundamental_Layout_Comprehension)
