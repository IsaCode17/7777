---
title: 元件化我們的 React 應用程式
slug: Learn/Tools_and_testing/Client-side_JavaScript_frameworks/React_components
tags:
  - 初學者
  - 框架
  - 狀態
  - 學習
  - 用戶端
  - 事件
  - 互動性 
  - Beginner
  - Frameworks
  - JavaScript
  - Learn
  - React
  - client-side
  - events
  - interactivity
  - state
---
<div>{{LearnSidebar}}</div>

<div>{{PreviousMenuNext("Learn/Tools_and_testing/Client-side_JavaScript_frameworks/React_todo_list_beginning","Learn/Tools_and_testing/Client-side_JavaScript_frameworks/React_interactivity_events_state", "Learn/Tools_and_testing/Client-side_JavaScript_frameworks")}}</div>

<p class="summary">現在，我們的應用程式已是個龐然大物。在我們讓它做點事之前，我們需要將它拆分成可管理的、描述性的元件。React對什麼是元件沒有任何硬性規定——這取決於你！在本文中，我們將向你展示一種將應用程式拆分成元件的合理作法。</p>

<table>
 <tbody>
  <tr>
   <th scope="row">預備知識：</th>
   <td>
    <p>熟悉基本的<a href="/zh-TW/docs/Learn/HTML">HTML</a>、<a href="/zh-TW/docs/Learn/CSS">CSS</a>、以及<a href="/zh-TW/docs/Learn/JavaScript">JavaScript</a>程式語言，具備<a href="/en-US/docs/Learn/Tools_and_testing/Understanding_client-side_tools/Command_line">終端機/命令列環境</a>的基本知識。</p>
   </td>
  </tr>
  <tr>
   <th scope="row">學習目標：</th>
   <td>展示一種將應用程式（待辦事項清單）拆分成元件的合理的作法。</td>
  </tr>
 </tbody>
</table>

<h2 id="Defining_our_first_component">定義我們的第一個元件</h2>

<p>在你進行一些實踐之前，定義元件似乎很棘手，但定義元件的要點是：</p>

<ul>
 <li>如果它代表你應用程式中明顯的「區塊(chunk)」，則它可能是一個元件。</li>
 <li>如果它經常被重複使用，則它可能是一個元件</li>
</ul>

<p>第二點特別重要：使用常見UI元素製作元件，這允許你在同個地方修改程式碼，並在使用該元件的任何地方查看這些更改。你也不必立即將所有內容拆分為元件。讓我們以第二個要點為靈感，並將最常重複使用、最重要UI部分製作一個元件：待辦事項清單。</p>

<h2 id="Make_a_&lt;Todo_&gt;">建立一個<code>&lt;Todo /&gt;</code>元件</h2>

<p>在我們製作元件之前，我們應該為它建立一個新檔案。事實上，我們應該為我們的元件建立一個目錄。下面的指令會建立一個<code>components</code>資料夾目錄，然後在其中創建一個名為<code>Todo.js</code>的檔案。在執行這些之前，請確保你位於應用程式的根目錄資料夾中！</p>

<pre class="brush: bash">mkdir src/components
touch src/components/Todo.js</pre>

<p>我們的新<code>Todo.js</code>檔案目前是空的！打開並對它寫下第一行：</p>

<pre class="brush: js">import React from "react";</pre>

<p>由於我們將建立一個名為<code>Todo</code>的元件，因此你也可以開始將其程式碼添加到<code>Todo.js</code>中，如下所示。在這段程式碼中，我們定義了函式並將其匯出到同一行：</p>

<pre class="brush: js">export default function Todo() {
  return (

  );
}</pre>

<p>到目前為止都還OK，但是我們的元件必須回傳一些東西！返回到<code>src/App.js</code>中，從無序清單中複製第一個<code><a href="/en-US/docs/Web/HTML/Element/li">&lt;li&gt;</a></code>，並將其貼到<code>Todo.js</code>中，使其讀起來像這樣：</p>

<pre class="brush: js">export default function Todo() {
  return (
    &lt;li className="todo stack-small"&gt;
      &lt;div className="c-cb"&gt;
        &lt;input id="todo-0" type="checkbox" defaultChecked={true} /&gt;
        &lt;label className="todo-label" htmlFor="todo-0"&gt;
          Eat
        &lt;/label&gt;
      &lt;/div&gt;
      &lt;div className="btn-group"&gt;
        &lt;button type="button" className="btn"&gt;
          Edit &lt;span className="visually-hidden"&gt;Eat&lt;/span&gt;
        &lt;/button&gt;
        &lt;button type="button" className="btn btn__danger"&gt;
          Delete &lt;span className="visually-hidden"&gt;Eat&lt;/span&gt;
        &lt;/button&gt;
      &lt;/div&gt;
    &lt;/li&gt;
  );
}</pre>

<div class="notecard note">
<p><strong>注意：</strong>元件總是必須回傳一些東西。如果你嘗試渲染一個不回傳任何內容的元件，React將在你的瀏覽器中顯示錯誤訊息。</p>
</div>

<p>我們的<code>Todo</code>元件完成了，至少現在是這樣；現在我們可以來使用它。在<code>App.js</code>中程式碼開頭頂部添加下面這行，以引入<code>Todo</code>元件：</p>

<pre class="brush: js">import Todo from "./components/Todo";</pre>

<p>引入此元件後，你可以將<code>App.js</code>中的所有<code>&lt;li&gt;</code>元素替換為<code>&lt;Todo /&gt;</code>元件。你的<code>&lt;ul&gt;</code>看起來應該是這個樣子：</p>

<pre class="brush: js">&lt;ul
  role="list"
  className="todo-list stack-large stack-exception"
  aria-labelledby="list-heading"
&gt;
  &lt;Todo /&gt;
  &lt;Todo /&gt;
  &lt;Todo /&gt;
&lt;/ul&gt;</pre>

<p>當你轉頭查看瀏覽器時，你會注意到一些糟糕的事情：你的清單現在重複第一個任務三遍！</p>

<p><img alt="Our todo list app, with todo components repeating because the label is hardcoded into the component" src="todo-list-repeating-todos.png"></p>

<p>我們不只是想吃東西；我們還有其他事情要做——呃..其他事——要做。接下來我們將看看如何調用不同元件以呈現獨特的內容。</p>

<h2 id="Make_a_unique_&lt;Todo_&gt;">建立<em>唯一的</em><code>&lt;Todo /&gt;</code>元件</h2>

<p>元件之所以強大，是因為它讓我們可以重複使用UI的各個部分，並在同個地方作為引用該UI的程式來源。問題是，我們通常不想重複使用每個元件；我們希望重複使用大部分零件，並更改小的細節。這時props就派上用場了。</p>

<h3 id="Whats_in_a_name"><code>name</code>裡有什麼?</h3>

<p>為了追蹤我們想要完成的任務名稱，我們應該確保每個<code>&lt;Todo /&gt;</code>元件顯示名稱是獨立唯一的。</p>

<p>在<code>App.js</code>中，給予每個<code>&lt;Todo /&gt;</code>元件設定名為name的prop屬性。讓我們使用之前的任務名稱：</p>

<pre class="brush: js">&lt;Todo name="Eat" /&gt;
&lt;Todo name="Sleep" /&gt;
&lt;Todo name="Repeat" /&gt;</pre>

<p>當你重新整理瀏覽器時，你將會看到...和以前完全一樣的畫面。我們給予<code>&lt;Todo /&gt;</code>元件傳遞了一些props參數，但我們還沒有使用到props它們。讓我們返回<code>Todo.js</code>中解決這個問題。</p>

<p>首先修改你定義的<code>Todo()</code>函式，使其將<code>props</code>作為參數傳入。如果你想檢查它們是否被元件正確接收到，你可以像我們以前那樣用<code>console.log()</code>來顯示你的<code>props</code>參數。</p>

<p>一旦你確定元件已取得<code>props</code>參數，你可以用你的props<code>name</code>來替換每次出現的<code>Eat</code>。記住：當你處於JSX表達式中間時，你可以使用花括號（<code>{</code>與<code>}</code>）來注入變數的值。</p>

<p>把這些全部放在一起，你的<code>Todo()</code>函式應該會像這樣：</p>

<pre class="brush: js">export default function Todo(props) {
  return (
    &lt;li className="todo stack-small"&gt;
      &lt;div className="c-cb"&gt;
        &lt;input id="todo-0" type="checkbox" defaultChecked={true} /&gt;
        &lt;label className="todo-label" htmlFor="todo-0"&gt;
          {props.name}
        &lt;/label&gt;
      &lt;/div&gt;
      &lt;div className="btn-group"&gt;
        &lt;button type="button" className="btn"&gt;
          Edit &lt;span className="visually-hidden"&gt;{props.name}&lt;/span&gt;
        &lt;/button&gt;
        &lt;button type="button" className="btn btn__danger"&gt;
          Delete &lt;span className="visually-hidden"&gt;{props.name}&lt;/span&gt;
        &lt;/button&gt;
      &lt;/div&gt;
    &lt;/li&gt;
  );
}</pre>

<p><em>現在</em>你的瀏覽器應該顯示三個獨立任務。但另一個問題仍然存在：預設情況下它們仍然被選取。</p>

<p><img alt="Our todo list, with different todo labels now they are passed into the components as props" src="todo-list-unique-todos.png"></p>

<h3 id="Is_it_completed">那麼，完成<code>completed</code>了嗎？</h3>

<p>在我們原來的靜態清單中，只有<code>Eat</code>被選取到。那麼再一次，我們希望只改變一件事，就能重複使用<em>大部分</em>UI來組成<code>&lt;Todo /&gt;</code>元件。該是另一個prop派上用場的時候了！給予每個在<code>App.js</code>中使用的<code>&lt;Todo /&gt;</code>元件一個新prop<code>completed</code>。第一個（<code>Eat</code>）的值應該是<code>true</code>；其餘的應該是<code>false</code>：</p>

<pre class="brush: js">&lt;Todo name="Eat" completed={true} /&gt;
&lt;Todo name="Sleep" completed={false} /&gt;
&lt;Todo name="Repeat" completed={false} /&gt;</pre>

<p>和之前一樣，我們必須返回<code>Todo.js</code>來實際使用這些props參數。更改<code>&lt;input /&gt;</code>上的<code>defaultChecked</code>屬性值，使其值等於<code>completed</code>屬性。完成後，Todo元件的<code>&lt;input /&gt;</code>元素看起來將是這樣：</p>

<pre class="brush: js">&lt;input id="todo-0" type="checkbox" defaultChecked={props.completed} /&gt;</pre>

<p>並且你的瀏覽器應該更新顯示被選中的<code>Eat</code>：</p>

<p><img alt="Our todo list app, now with differing checked states - some checkboxes are checked, others not" src="todo-list-differing-checked-states.png"></p>

<p>如果你修改每個<code>&lt;Todo /&gt;</code>元件的<code>completed</code>prop參數，你的瀏覽器將對應顯示已選取或被取消的複選框。</p>

<h3 id="Gimme_some_id_please">請設定一些<code>id</code></h3>

<p>現在，我們的 <code>&lt;Todo /&gt;</code>元件賦予了每個任務相同的<code>id</code>屬性<code>todo-0</code>。這是一段糟糕的HTML，因為<a href="/en-US/docs/Web/HTML/Global_attributes/id"><code>id</code>屬性</a>必須是唯一的（它們被CSS、JavaScript..等用來作為文件片段的唯一識別碼。）。這意味著我們應該給我們的元件一個<code>id</code>屬性，這個<code>id</code>屬性會為每個<code>Todo</code>提供一個唯一值。</p>

<p>遵循我們最初的模式，讓我們給<code>&lt;Todo /&gt;</code>元件的每個實體一個<code>todo-i</code>格式的ID，其中的<code>i</code>數值每次都會加1變多：</p>

<pre class="brush: js">&lt;Todo name="Eat" completed={true} id="todo-0" /&gt;
&lt;Todo name="Sleep" completed={false} id="todo-1" /&gt;
&lt;Todo name="Repeat" completed={false} id="todo-2" /&gt;</pre>

<p>現在回到<code>Todo.js</code>並使用<code>id</code>prop。將<code>&lt;input /&gt;</code>元素的屬性<code>id</code>值，以及其標籤的屬性<code>htmlFor</code>值都用props的<code>id</code>替換掉：</p>

<pre class="brush: js">&lt;div className="c-cb"&gt;
  &lt;input id={props.id} type="checkbox" defaultChecked={props.completed} /&gt;
  &lt;label className="todo-label" htmlFor={props.id}&gt;
    {props.name}
  &lt;/label&gt;
&lt;/div&gt;</pre>

<h2 id="So_far_so_good">到目前為止，一切還算順利？</h2>

<p>目前我們很好地使用了React，但我們可以做得更好！我們的程式碼有重複的部分。渲染<code>&lt;Todo /&gt;</code>元件的程式碼有三行幾乎相同，它們只有一個差異：每個prop的值不同。</p>

<p>我們可以使用JavaScript的核心功能之一——迭代（iteration）來清理（clean up）程式碼。要使用迭代，首先應該重新考慮我們的任務。</p>

<h2 id="Tasks_as_data">將任務們轉換成數據資料</h2>

<p>目前我們的每個任務都包含三資訊：它的名稱、它是否被檢查過，以及它的唯一ID。這些資料可以很好地轉換成物件格式。尤於我們有好幾個任務，因此一個包含有數個物件的陣列資料結構（array of objects）可以很好地表示這些資料。</p>

<p>在<code>src/index.js</code>中，在最後一個<code>import</code>引入語法的程式碼下方，且在<code>ReactDOM.render()</code>上方的段落撰寫宣告一個新的<code>const</code>常數：</p>

<pre class="brush: js">const DATA = [
  { id: "todo-0", name: "Eat", completed: true },
  { id: "todo-1", name: "Sleep", completed: false },
  { id: "todo-2", name: "Repeat", completed: false }
];</pre>

<p>接下來，我們將<code>DATA</code>稱為<code>tasks</code>作為prop參數的值傳遞給<code>&lt;App /&gt;</code>元件。在<code>src/index.js</code>的最後一行應該像這樣：</p>

<pre class="brush: js">ReactDOM.render(&lt;App tasks={DATA} /&gt;, document.getElementById("root"));</pre>

<p>這個陣列現在作為<code>props.tasks</code>提供給App元件。如果你想的話，你還可以用<code>console.log()</code>來檢查一下。</p>

<div class="notecard note">
<p><strong>注意：</strong><code>ALL_CAPS</code>常數名稱在JavaScript中沒有特殊意義；它們是一個約定，告訴其他開發人員「這些數據資料在此定義後將永遠不會改變」。</p>
</div>

<h2 id="Rendering_with_iteration">迭代渲染</h2>

<p>為了要渲染含有物件的陣列資料結構（array of objects），我們須要將每個物件都轉換成一個<code>&lt;Todo /&gt;</code>元件。JavaScript為我們提供了一種將資料轉換為其他內容的陣列方法：<code><a href="/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/map">Array.prototype.map()</a></code>。</p>

<p>在<code>App()</code>的return語句之前，新建一個<code>const</code>常數並命名名為<code>taskList</code>，並且使用<code>map()</code>來轉換它。讓我們開始將<code>tasks</code>陣列轉換成一些簡單的東西：例如每個任務的<code>name</code>：</p>

<pre class="brush: js">const taskList = props.tasks.map(task =&gt; task.name);</pre>

<p>讓我們嘗試用<code>taskList</code>替換<code>&lt;ul&gt;</code>全部的子元素：</p>

<pre class="brush: js">&lt;ul
  role="list"
  className="todo-list stack-large stack-exception"
  aria-labelledby="list-heading"
&gt;
  {taskList}
&lt;/ul&gt;</pre>

<p>這使我們能夠再次顯示所有元件，但我們還有更多工作要做：瀏覽器顯示目前每個任務名稱為非結構化的字串。我們的HTML結構缺少<code>&lt;li&gt;</code>標籤以及其複選框與按鈕！</p>

<p><img alt="Our todo list app with the todo item labels just shown bunched up on one line" src="todo-list-unstructured-names.png"></p>

<p>為了修正這個問題，我們需要從<code>map()</code>函式中回傳<code>&lt;Todo /&gt;</code>元件——請記住，JSX允許我們混合使用標記式結構與JavaScript！讓我們嘗試下面還沒做過的方法：</p>

<pre class="brush: js"> const taskList = props.tasks.map(task =&gt; &lt;Todo /&gt;);</pre>

<p>再看看你的應用程式；現在我們的任務看起來更像以前的樣子了，但它們還缺少任務本身的名稱。請記得，我們希望傳遞給<code>&lt;Todo /&gt;</code>元件每個映射的任務，都要有<code>id</code>、<code>name</code>與<code>checked</code>屬性。如果我們把這些知識合在一起，我們會得到這樣的程式碼：</p>

<pre class="brush: js">const taskList = props.tasks.map(task =&gt; (
  &lt;Todo id={task.id} name={task.name} completed={task.completed} /&gt;
));</pre>

<p>現在應用程式看起來和以前一樣，而且我們的程式碼沒有重複部分了。</p>

<h2 id="Unique_keys">唯一的鍵值（Unique keys）</h2>

<p>現在React正從陣列資料中來渲染我們的任務項目，React必須追蹤<strong>哪個是哪個</strong>以便正確渲染顯示項目。React會嘗試通過自己的猜測來追踪事情，但我們可以通過將<code>key</code>prop屬性傳遞給我們的<code>&lt;Todo /&gt;</code>元件來幫助它。<code>key</code>是一個由React管理的特殊prop——你不能將<code>key</code>這個詞用在其他目的上。</p>

<p>因為鍵（keys）應該是唯一的，我們將重新使用每個任務物件的<code>id</code>作為其鍵（key）。像這樣更新你的<code>taskList</code>常數：</p>

<pre class="brush: js">const taskList = props.tasks.map(task =&gt; (
    &lt;Todo
      id={task.id}
      name={task.name}
      completed={task.completed}
      key={task.id}
    /&gt;
  )
);</pre>

<p><strong>你應該始終將唯一鍵（unique keys）傳遞給任何你用迭代渲染的東西裡。</strong>在你的瀏覽器中沒有什麼明顯變化，但如果你不使用唯一鍵（unique keys），React就會到你的console控制台發出警告訊息，並且你的應用程式可能會表現的很奇怪！</p>

<h2 id="Componentizing_the_rest_of_the_app">將應用程式的剩餘部分也元件化</h2>

<p>現在我們已整理好最重要的元件，我們可以將應用程式的剩餘部分也轉成元件。要記住元件要馬是明顯的UI部分，要馬是重複使用的UI部分，或者兩者都是，我們可以再製作兩個元件：</p>

<ul>
 <li><code>&lt;Form/&gt;</code></li>
 <li><code>&lt;FilterButton/&gt;</code></li>
</ul>

<p>鑒於我們知道這兩個元件都是需要的，我們可以使用終端機指令批次處理一些建立檔案的工作。注意你位於應用程式的根目錄中，在終端機執行此指令：</p>

<pre class="brush: bash">touch src/components/Form.js src/components/FilterButton.js</pre>

<h3 id="The_&lt;Form_&gt;"><code>&lt;Form /&gt;</code>元件</h3>

<p>打開<code>components/Form.js</code>檔案並執行下列操作：</p>

<ul>
 <li>在文件檔案的最開頭Import引入<code>React</code>，就像我們在<code>Todo.js</code>做的一樣。</li>
 <li>建立一個基本結構與<code>Todo()</code>相同的新<code>Form()</code>元件，並將匯出。</li>
 <li>從<code>App.js</code>內複製<code>&lt;form&gt;</code>標籤以及它們之間的所有內容，並將它們轉貼到<code>Form()</code>的<code>return</code>語句那邊。</li>
 <li>在文件檔案的最末段Export匯出<code>Form</code></li>
</ul>

<p>你的<code>Form.js</code>檔案看起來應該是這樣：</p>

<pre class="brush: js">import React from "react";

function Form(props) {
  return (
    &lt;form&gt;
      &lt;h2 className="label-wrapper"&gt;
        &lt;label htmlFor="new-todo-input" className="label__lg"&gt;
          What needs to be done?
        &lt;/label&gt;
      &lt;/h2&gt;
      &lt;input
        type="text"
        id="new-todo-input"
        className="input input__lg"
        name="text"
        autoComplete="off"
      /&gt;
      &lt;button type="submit" className="btn btn__primary btn__lg"&gt;
        Add
      &lt;/button&gt;
    &lt;/form&gt;
  );
}

export default Form;</pre>

<h3 id="The_&lt;FilterButton_&gt;">&lt;FilterButton /&gt;元件</h3>

<p>執行與在<code>FilterButton.js</code>中建立<code>Form.js</code>一樣的操作，從<code>App.js</code>中調用元件<code>FilterButton()</code>，並複製在<code>&lt;div&gt;</code>元素內第一個按鈕的HTML，從<code>class</code>到<code>filters</code>的段落至<code>return</code>這邊。</p>

<p>現在檔案看起來應該像這樣：</p>

<pre class="brush: js">import React from "react";

function FilterButton(props) {
  return (
    &lt;button type="button" className="btn toggle-btn" aria-pressed="true"&gt;
      &lt;span className="visually-hidden"&gt;Show &lt;/span&gt;
      &lt;span&gt;all &lt;/span&gt;
      &lt;span className="visually-hidden"&gt; tasks&lt;/span&gt;
    &lt;/button&gt;
  );
}

export default FilterButton;</pre>

<div class="notecard note">
<p><strong>注意：</strong>你可能會注意到，我們在這裡犯了與第一次為<code>&lt;Todo /&gt;</code>元件犯的相同的錯誤，因為每個按鈕都是相同的。沒關係！我們稍後會在<a href="/en-US/docs/Learn/Tools_and_testing/Client-side_JavaScript_frameworks/React_interactivity_filtering_conditional_rendering#back_to_the_filter_buttons">Back to the filter buttons</a>章節修好這個元件。</p>
</div>

<h2 id="Importing_all_our_components">引入我們所有的元件</h2>

<p>讓我們使用我們的新元件。</p>

<p>在<code>App.js</code>中的程式碼頂部加入更多<code>import</code>語句以引入它們。</p>

<p>然後，更新<code>App()</code>的<code>return</code>語句，使其呈現我們的元件。當你完成後，<code>App.js</code>將如下所示：</p>

<pre class="brush: js">import React from "react";
import Form from "./components/Form";
import FilterButton from "./components/FilterButton";
import Todo from "./components/Todo";

function App(props) {
  const taskList = props.tasks.map(task =&gt; (
    &lt;Todo
        id={task.id}
        name={task.name}
        completed={task.completed}
        key={task.id}
      /&gt;
    )
  );
  return (
    &lt;div className="todoapp stack-large"&gt;
      &lt;h1&gt;TodoMatic&lt;/h1&gt;
      &lt;Form /&gt;
      &lt;div className="filters btn-group stack-exception"&gt;
        &lt;FilterButton /&gt;
        &lt;FilterButton /&gt;
        &lt;FilterButton /&gt;
      &lt;/div&gt;
      &lt;h2 id="list-heading"&gt;3 tasks remaining&lt;/h2&gt;
      &lt;ul
        role="list"
        className="todo-list stack-large stack-exception"
        aria-labelledby="list-heading"
      &gt;
        {taskList}
      &lt;/ul&gt;
    &lt;/div&gt;
  );
}

export default App;</pre>

<p>有了這個，我們<em>幾乎</em>準備好在我們的React應用程式中解決一些互動性問題！</p>

<h2 id="Summary">總結</h2>

<p>這就是本文的內容——我們已深入探討如何將你的應用程式很好地拆分成元件，並有效地呈現它們。現在我們將繼續看如何在React中處理事件，並開始添加一些互動性。</p>

<p>{{PreviousMenuNext("Learn/Tools_and_testing/Client-side_JavaScript_frameworks/React_todo_list_beginning","Learn/Tools_and_testing/Client-side_JavaScript_frameworks/React_interactivity_events_state", "Learn/Tools_and_testing/Client-side_JavaScript_frameworks")}}</p>

<h2 id="In_this_module">在這個模組中</h2>

<ul>
 <li><a href="/en-US/docs/Learn/Tools_and_testing/Client-side_JavaScript_frameworks/Introduction">Introduction to client-side frameworks</a></li>
 <li><a href="/en-US/docs/Learn/Tools_and_testing/Client-side_JavaScript_frameworks/Main_features">Framework main features</a></li>
 <li>React
  <ul>
   <li><a href="/en-US/docs/Learn/Tools_and_testing/Client-side_JavaScript_frameworks/React_getting_started">Getting started with React</a></li>
   <li><a href="/en-US/docs/Learn/Tools_and_testing/Client-side_JavaScript_frameworks/React_todo_list_beginning">Beginning our React todo list</a></li>
   <li><a href="/en-US/docs/Learn/Tools_and_testing/Client-side_JavaScript_frameworks/React_components">Componentizing our React app</a></li>
   <li><a href="/en-US/docs/Learn/Tools_and_testing/Client-side_JavaScript_frameworks/React_interactivity_events_state">React interactivity: Events and state</a></li>
   <li><a href="/en-US/docs/Learn/Tools_and_testing/Client-side_JavaScript_frameworks/React_interactivity_filtering_conditional_rendering">React interactivity: Editing, filtering, conditional rendering</a></li>
   <li><a href="/en-US/docs/Learn/Tools_and_testing/Client-side_JavaScript_frameworks/React_accessibility">Accessibility in React</a></li>
   <li><a href="/en-US/docs/Learn/Tools_and_testing/Client-side_JavaScript_frameworks/React_resources">React resources</a></li>
  </ul>
 </li>
 <li>Ember
  <ul>
   <li><a href="/en-US/docs/Learn/Tools_and_testing/Client-side_JavaScript_frameworks/Ember_getting_started">Getting started with Ember</a></li>
   <li><a href="/en-US/docs/Learn/Tools_and_testing/Client-side_JavaScript_frameworks/Ember_structure_componentization">Ember app structure and componentization</a></li>
   <li><a href="/en-US/docs/Learn/Tools_and_testing/Client-side_JavaScript_frameworks/Ember_interactivity_events_state">Ember interactivity: Events, classes and state</a></li>
   <li><a href="/en-US/docs/Learn/Tools_and_testing/Client-side_JavaScript_frameworks/Ember_conditional_footer">Ember Interactivity: Footer functionality, conditional rendering</a></li>
   <li><a href="/en-US/docs/Learn/Tools_and_testing/Client-side_JavaScript_frameworks/Ember_routing">Routing in Ember</a></li>
   <li><a href="/en-US/docs/Learn/Tools_and_testing/Client-side_JavaScript_frameworks/Ember_resources">Ember resources and troubleshooting</a></li>
  </ul>
 </li>
 <li>Vue
  <ul>
   <li><a href="/en-US/docs/Learn/Tools_and_testing/Client-side_JavaScript_frameworks/Vue_getting_started">Getting started with Vue</a></li>
   <li><a href="/en-US/docs/Learn/Tools_and_testing/Client-side_JavaScript_frameworks/Vue_first_component">Creating our first Vue component</a></li>
   <li><a href="/en-US/docs/Learn/Tools_and_testing/Client-side_JavaScript_frameworks/Vue_rendering_lists">Rendering a list of Vue components</a></li>
   <li><a href="/en-US/docs/Learn/Tools_and_testing/Client-side_JavaScript_frameworks/Vue_methods_events_models">Adding a new todo form: Vue events, methods, and models</a></li>
   <li><a href="/en-US/docs/Learn/Tools_and_testing/Client-side_JavaScript_frameworks/Vue_styling">Styling Vue components with CSS</a></li>
   <li><a href="/en-US/docs/Learn/Tools_and_testing/Client-side_JavaScript_frameworks/Vue_computed_properties">Using Vue computed properties</a></li>
   <li><a href="/en-US/docs/Learn/Tools_and_testing/Client-side_JavaScript_frameworks/Vue_conditional_rendering">Vue conditional rendering: editing existing todos</a></li>
   <li><a href="/en-US/docs/Learn/Tools_and_testing/Client-side_JavaScript_frameworks/Vue_refs_focus_management">Focus management with Vue refs</a></li>
   <li><a href="/en-US/docs/Learn/Tools_and_testing/Client-side_JavaScript_frameworks/Vue_resources">Vue resources</a></li>
  </ul>
 </li>
 <li>Svelte
  <ul>
   <li><a href="/en-US/docs/Learn/Tools_and_testing/Client-side_JavaScript_frameworks/Svelte_getting_started">Getting started with Svelte</a></li>
   <li><a href="/en-US/docs/Learn/Tools_and_testing/Client-side_JavaScript_frameworks/Svelte_Todo_list_beginning">Starting our Svelte Todo list app</a></li>
   <li><a href="/en-US/docs/Learn/Tools_and_testing/Client-side_JavaScript_frameworks/Svelte_variables_props">Dynamic behavior in Svelte: working with variables and props</a></li>
   <li><a href="/en-US/docs/Learn/Tools_and_testing/Client-side_JavaScript_frameworks/Svelte_components">Componentizing our Svelte app</a></li>
   <li><a href="/en-US/docs/Learn/Tools_and_testing/Client-side_JavaScript_frameworks/Svelte_reactivity_lifecycle_accessibility">Advanced Svelte: Reactivity, lifecycle, accessibility</a></li>
   <li><a href="/en-US/docs/Learn/Tools_and_testing/Client-side_JavaScript_frameworks/Svelte_stores">Working with Svelte stores</a></li>
   <li><a href="/en-US/docs/Learn/Tools_and_testing/Client-side_JavaScript_frameworks/Svelte_TypeScript">TypeScript support in Svelte</a></li>
   <li><a href="/en-US/docs/Learn/Tools_and_testing/Client-side_JavaScript_frameworks/Svelte_deployment_next">Deployment and next steps</a></li>
  </ul>
 </li>
 <li>Angular
   <ul>
    <li><a href="/en-US/docs/Learn/Tools_and_testing/Client-side_JavaScript_frameworks/Angular_getting_started">Getting started with Angular</a></li>
    <li><a href="/en-US/docs/Learn/Tools_and_testing/Client-side_JavaScript_frameworks/Angular_todo_list_beginning">Beginning our Angular todo list app</a></li>
    <li><a href="/en-US/docs/Learn/Tools_and_testing/Client-side_JavaScript_frameworks/Angular_styling">Styling our Angular app</a></li>
    <li><a href="/en-US/docs/Learn/Tools_and_testing/Client-side_JavaScript_frameworks/Angular_item_component">Creating an item component</a></li>
    <li><a href="/en-US/docs/Learn/Tools_and_testing/Client-side_JavaScript_frameworks/Angular_filtering">Filtering our to-do items</a></li>
    <li><a href="/en-US/docs/Learn/Tools_and_testing/Client-side_JavaScript_frameworks/Angular_building">Building Angular applications and further resources</a></li>
   </ul>
 </li>
</ul>
